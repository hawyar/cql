// Code generated from ./grammar/cql.g4 by ANTLR 4.12.0. DO NOT EDIT.

package parser // cql

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type cqlParser struct {
	*antlr.BaseParser
}

var cqlParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func cqlParserInit() {
	staticData := &cqlParserStaticData
	staticData.literalNames = []string{
		"", "'library'", "'version'", "'using'", "'include'", "'called'", "'public'",
		"'private'", "'parameter'", "'default'", "'codesystem'", "':'", "'valueset'",
		"'codesystems'", "'{'", "','", "'}'", "'.'", "'code'", "'from'", "'concept'",
		"'List'", "'<'", "'>'", "'Interval'", "'Tuple'", "'Choice'", "'define'",
		"'context'", "'function'", "'('", "')'", "'returns'", "'external'",
		"'with'", "'such that'", "'without'", "'['", "'->'", "'in'", "']'",
		"'let'", "'where'", "'return'", "'all'", "'distinct'", "'sort'", "'by'",
		"'asc'", "'ascending'", "'desc'", "'descending'", "'is'", "'not'", "'null'",
		"'true'", "'false'", "'as'", "'cast'", "'exists'", "'properly'", "'between'",
		"'and'", "'duration'", "'difference'", "'<='", "'>='", "'='", "'!='",
		"'~'", "'!~'", "'contains'", "'or'", "'xor'", "'implies'", "'|'", "'union'",
		"'intersect'", "'except'", "'year'", "'month'", "'week'", "'day'", "'hour'",
		"'minute'", "'second'", "'millisecond'", "'date'", "'time'", "'timezoneoffset'",
		"'years'", "'months'", "'weeks'", "'days'", "'hours'", "'minutes'",
		"'seconds'", "'milliseconds'", "'convert'", "'to'", "'+'", "'-'", "'start'",
		"'end'", "'of'", "'width'", "'successor'", "'predecessor'", "'singleton'",
		"'point'", "'minimum'", "'maximum'", "'^'", "'*'", "'/'", "'div'", "'mod'",
		"'&'", "'if'", "'then'", "'else'", "'case'", "'flatten'", "'expand'",
		"'collapse'", "'per'", "'when'", "'or before'", "'or after'", "'or more'",
		"'or less'", "'less than'", "'more than'", "'on or'", "'before'", "'after'",
		"'or on'", "'starts'", "'ends'", "'occurs'", "'same'", "'includes'",
		"'during'", "'included in'", "'within'", "'meets'", "'overlaps'", "'$this'",
		"'$index'", "'$total'", "'display'", "'Code'", "'Concept'", "'%'",
	}
	staticData.symbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "QUOTEDIDENTIFIER", "DATETIME", "TIME", "IDENTIFIER", "DELIMITEDIDENTIFIER",
		"STRING", "NUMBER", "WS", "COMMENT", "LINE_COMMENT",
	}
	staticData.ruleNames = []string{
		"library", "libraryDefinition", "usingDefinition", "includeDefinition",
		"localIdentifier", "accessModifier", "parameterDefinition", "codesystemDefinition",
		"valuesetDefinition", "codesystems", "codesystemIdentifier", "libraryIdentifier",
		"codeDefinition", "conceptDefinition", "codeIdentifier", "codesystemId",
		"valuesetId", "versionSpecifier", "codeId", "typeSpecifier", "namedTypeSpecifier",
		"modelIdentifier", "listTypeSpecifier", "intervalTypeSpecifier", "tupleTypeSpecifier",
		"tupleElementDefinition", "choiceTypeSpecifier", "statement", "expressionDefinition",
		"contextDefinition", "functionDefinition", "operandDefinition", "functionBody",
		"querySource", "aliasedQuerySource", "alias", "queryInclusionClause",
		"withClause", "withoutClause", "retrieve", "contextIdentifier", "codePath",
		"terminology", "qualifier", "query", "sourceClause", "letClause", "letClauseItem",
		"whereClause", "returnClause", "sortClause", "sortDirection", "sortByItem",
		"qualifiedIdentifier", "qualifiedIdentifierExpression", "qualifierExpression",
		"simplePath", "simpleLiteral", "expression", "dateTimePrecision", "dateTimeComponent",
		"pluralDateTimePrecision", "expressionTerm", "caseExpressionItem", "dateTimePrecisionSpecifier",
		"relativeQualifier", "offsetRelativeQualifier", "exclusiveRelativeQualifier",
		"quantityOffset", "temporalRelationship", "intervalOperatorPhrase",
		"term", "qualifiedInvocation", "qualifiedFunction", "invocation", "function",
		"ratio", "literal", "intervalSelector", "tupleSelector", "tupleElementSelector",
		"instanceSelector", "instanceElementSelector", "listSelector", "displayClause",
		"codeSelector", "conceptSelector", "keyword", "reservedWord", "keywordIdentifier",
		"obsoleteIdentifier", "functionIdentifier", "typeNameIdentifier", "referentialIdentifier",
		"referentialOrTypeNameIdentifier", "identifierOrFunctionIdentifier",
		"identifier", "externalConstant", "paramList", "quantity", "unit",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 163, 1168, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 1, 0, 3, 0, 204, 8, 0, 1, 0, 5, 0, 207, 8, 0, 10, 0,
		12, 0, 210, 9, 0, 1, 0, 5, 0, 213, 8, 0, 10, 0, 12, 0, 216, 9, 0, 1, 0,
		5, 0, 219, 8, 0, 10, 0, 12, 0, 222, 9, 0, 1, 0, 5, 0, 225, 8, 0, 10, 0,
		12, 0, 228, 9, 0, 1, 0, 5, 0, 231, 8, 0, 10, 0, 12, 0, 234, 9, 0, 1, 0,
		5, 0, 237, 8, 0, 10, 0, 12, 0, 240, 9, 0, 1, 0, 5, 0, 243, 8, 0, 10, 0,
		12, 0, 246, 9, 0, 1, 0, 5, 0, 249, 8, 0, 10, 0, 12, 0, 252, 9, 0, 1, 0,
		1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 260, 8, 1, 1, 2, 1, 2, 1, 2, 1, 2,
		3, 2, 266, 8, 2, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 272, 8, 3, 1, 3, 1, 3, 3,
		3, 276, 8, 3, 1, 4, 1, 4, 1, 5, 1, 5, 1, 6, 3, 6, 283, 8, 6, 1, 6, 1, 6,
		1, 6, 3, 6, 288, 8, 6, 1, 6, 1, 6, 3, 6, 292, 8, 6, 1, 7, 3, 7, 295, 8,
		7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 303, 8, 7, 1, 8, 3, 8, 306,
		8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 314, 8, 8, 1, 8, 3, 8,
		317, 8, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 5, 9, 324, 8, 9, 10, 9, 12, 9,
		327, 9, 9, 1, 9, 1, 9, 1, 10, 1, 10, 1, 10, 3, 10, 334, 8, 10, 1, 10, 1,
		10, 1, 11, 1, 11, 1, 12, 3, 12, 341, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 3, 12, 350, 8, 12, 1, 13, 3, 13, 353, 8, 13, 1, 13,
		1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 5, 13, 362, 8, 13, 10, 13, 12,
		13, 365, 9, 13, 1, 13, 1, 13, 3, 13, 369, 8, 13, 1, 14, 1, 14, 1, 14, 3,
		14, 374, 8, 14, 1, 14, 1, 14, 1, 15, 1, 15, 1, 16, 1, 16, 1, 17, 1, 17,
		1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 391, 8, 19, 1,
		20, 1, 20, 1, 20, 5, 20, 396, 8, 20, 10, 20, 12, 20, 399, 9, 20, 1, 20,
		1, 20, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 23, 1, 23, 1,
		23, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 5, 24, 420, 8, 24,
		10, 24, 12, 24, 423, 9, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1, 25, 1, 26, 1,
		26, 1, 26, 1, 26, 1, 26, 5, 26, 435, 8, 26, 10, 26, 12, 26, 438, 9, 26,
		1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 3, 27, 445, 8, 27, 1, 28, 1, 28, 3,
		28, 449, 8, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 1, 29,
		3, 29, 459, 8, 29, 1, 29, 1, 29, 1, 30, 1, 30, 3, 30, 465, 8, 30, 1, 30,
		1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 5, 30, 473, 8, 30, 10, 30, 12, 30, 476,
		9, 30, 3, 30, 478, 8, 30, 1, 30, 1, 30, 1, 30, 3, 30, 483, 8, 30, 1, 30,
		1, 30, 1, 30, 3, 30, 488, 8, 30, 1, 31, 1, 31, 1, 31, 1, 32, 1, 32, 1,
		33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 501, 8, 33, 1, 34, 1, 34,
		1, 34, 1, 35, 1, 35, 1, 36, 1, 36, 3, 36, 510, 8, 36, 1, 37, 1, 37, 1,
		37, 1, 37, 1, 37, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 39, 1, 39, 1, 39,
		1, 39, 3, 39, 526, 8, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 3, 39, 533,
		8, 39, 1, 39, 3, 39, 536, 8, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 41, 1,
		41, 1, 42, 1, 42, 3, 42, 546, 8, 42, 1, 43, 1, 43, 1, 44, 1, 44, 3, 44,
		552, 8, 44, 1, 44, 5, 44, 555, 8, 44, 10, 44, 12, 44, 558, 9, 44, 1, 44,
		3, 44, 561, 8, 44, 1, 44, 3, 44, 564, 8, 44, 1, 44, 3, 44, 567, 8, 44,
		1, 45, 3, 45, 570, 8, 45, 1, 45, 1, 45, 1, 45, 5, 45, 575, 8, 45, 10, 45,
		12, 45, 578, 9, 45, 1, 46, 1, 46, 1, 46, 1, 46, 5, 46, 584, 8, 46, 10,
		46, 12, 46, 587, 9, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48,
		1, 49, 1, 49, 3, 49, 598, 8, 49, 1, 49, 1, 49, 1, 50, 1, 50, 1, 50, 1,
		50, 1, 50, 1, 50, 5, 50, 608, 8, 50, 10, 50, 12, 50, 611, 9, 50, 3, 50,
		613, 8, 50, 1, 51, 1, 51, 1, 52, 1, 52, 3, 52, 619, 8, 52, 1, 53, 1, 53,
		1, 53, 5, 53, 624, 8, 53, 10, 53, 12, 53, 627, 9, 53, 1, 53, 1, 53, 1,
		54, 1, 54, 1, 54, 5, 54, 634, 8, 54, 10, 54, 12, 54, 637, 9, 54, 1, 54,
		1, 54, 1, 55, 1, 55, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1,
		56, 1, 56, 1, 56, 1, 56, 5, 56, 654, 8, 56, 10, 56, 12, 56, 657, 9, 56,
		1, 57, 1, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1,
		58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 676, 8, 58, 1, 58,
		1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1,
		58, 1, 58, 1, 58, 3, 58, 692, 8, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58,
		1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 707, 8,
		58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58,
		1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 725, 8, 58, 1, 58, 1,
		58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 733, 8, 58, 1, 58, 1, 58, 1, 58,
		1, 58, 1, 58, 5, 58, 740, 8, 58, 10, 58, 12, 58, 743, 9, 58, 1, 59, 1,
		59, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 751, 8, 60, 1, 61, 1, 61, 1, 62,
		1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 3, 62, 762, 8, 62, 1, 62, 1,
		62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62,
		1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1,
		62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62,
		1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1,
		62, 1, 62, 1, 62, 1, 62, 3, 62, 811, 8, 62, 1, 62, 4, 62, 814, 8, 62, 11,
		62, 12, 62, 815, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62,
		1, 62, 1, 62, 1, 62, 3, 62, 829, 8, 62, 3, 62, 831, 8, 62, 3, 62, 833,
		8, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1,
		62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 5, 62, 852, 8, 62,
		10, 62, 12, 62, 855, 9, 62, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 64, 1,
		64, 1, 64, 1, 65, 1, 65, 1, 66, 1, 66, 1, 67, 1, 67, 1, 68, 1, 68, 3, 68,
		873, 8, 68, 1, 68, 1, 68, 1, 68, 3, 68, 878, 8, 68, 1, 69, 3, 69, 881,
		8, 69, 1, 69, 1, 69, 1, 69, 3, 69, 886, 8, 69, 3, 69, 888, 8, 69, 1, 70,
		3, 70, 891, 8, 70, 1, 70, 1, 70, 3, 70, 895, 8, 70, 1, 70, 1, 70, 3, 70,
		899, 8, 70, 1, 70, 3, 70, 902, 8, 70, 1, 70, 3, 70, 905, 8, 70, 1, 70,
		1, 70, 3, 70, 909, 8, 70, 1, 70, 3, 70, 912, 8, 70, 1, 70, 3, 70, 915,
		8, 70, 1, 70, 3, 70, 918, 8, 70, 1, 70, 1, 70, 3, 70, 922, 8, 70, 1, 70,
		3, 70, 925, 8, 70, 1, 70, 3, 70, 928, 8, 70, 1, 70, 1, 70, 3, 70, 932,
		8, 70, 1, 70, 3, 70, 935, 8, 70, 1, 70, 3, 70, 938, 8, 70, 1, 70, 3, 70,
		941, 8, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 947, 8, 70, 1, 70, 1, 70,
		3, 70, 951, 8, 70, 1, 70, 3, 70, 954, 8, 70, 1, 70, 1, 70, 3, 70, 958,
		8, 70, 1, 70, 3, 70, 961, 8, 70, 1, 70, 1, 70, 3, 70, 965, 8, 70, 1, 70,
		1, 70, 3, 70, 969, 8, 70, 3, 70, 971, 8, 70, 1, 71, 1, 71, 1, 71, 1, 71,
		1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 986,
		8, 71, 1, 72, 1, 72, 3, 72, 990, 8, 72, 1, 73, 1, 73, 1, 73, 3, 73, 995,
		8, 73, 1, 73, 1, 73, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 1004, 8,
		74, 1, 75, 1, 75, 1, 75, 3, 75, 1009, 8, 75, 1, 75, 1, 75, 1, 76, 1, 76,
		1, 76, 1, 76, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 3,
		77, 1025, 8, 77, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 79,
		3, 79, 1035, 8, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 5, 79, 1042, 8,
		79, 10, 79, 12, 79, 1045, 9, 79, 3, 79, 1047, 8, 79, 1, 79, 1, 79, 1, 80,
		1, 80, 1, 80, 1, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 5, 81, 1061,
		8, 81, 10, 81, 12, 81, 1064, 9, 81, 3, 81, 1066, 8, 81, 1, 81, 1, 81, 1,
		82, 1, 82, 1, 82, 1, 82, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83, 1079,
		8, 83, 3, 83, 1081, 8, 83, 1, 83, 1, 83, 1, 83, 1, 83, 5, 83, 1087, 8,
		83, 10, 83, 12, 83, 1090, 9, 83, 3, 83, 1092, 8, 83, 1, 83, 1, 83, 1, 84,
		1, 84, 1, 84, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 3, 85, 1104, 8, 85, 1,
		86, 1, 86, 1, 86, 1, 86, 1, 86, 5, 86, 1111, 8, 86, 10, 86, 12, 86, 1114,
		9, 86, 1, 86, 1, 86, 3, 86, 1118, 8, 86, 1, 87, 1, 87, 1, 88, 1, 88, 1,
		89, 1, 89, 1, 90, 1, 90, 1, 91, 1, 91, 1, 92, 1, 92, 1, 93, 1, 93, 3, 93,
		1134, 8, 93, 1, 94, 1, 94, 3, 94, 1138, 8, 94, 1, 95, 1, 95, 3, 95, 1142,
		8, 95, 1, 96, 1, 96, 1, 97, 1, 97, 1, 97, 3, 97, 1149, 8, 97, 1, 98, 1,
		98, 1, 98, 5, 98, 1154, 8, 98, 10, 98, 12, 98, 1157, 9, 98, 1, 99, 1, 99,
		3, 99, 1161, 8, 99, 1, 100, 1, 100, 1, 100, 3, 100, 1166, 8, 100, 1, 100,
		0, 3, 112, 116, 124, 101, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24,
		26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60,
		62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96,
		98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126,
		128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156,
		158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186,
		188, 190, 192, 194, 196, 198, 200, 0, 36, 1, 0, 6, 7, 1, 0, 44, 45, 1,
		0, 48, 51, 1, 0, 159, 160, 2, 0, 22, 23, 65, 66, 1, 0, 67, 70, 2, 0, 39,
		39, 71, 71, 1, 0, 72, 73, 1, 0, 75, 78, 1, 0, 54, 56, 2, 0, 52, 52, 57,
		57, 1, 0, 79, 86, 1, 0, 90, 97, 1, 0, 100, 101, 1, 0, 102, 103, 1, 0, 110,
		111, 2, 0, 45, 45, 122, 122, 1, 0, 123, 124, 1, 0, 113, 116, 2, 0, 100,
		101, 117, 117, 1, 0, 127, 128, 1, 0, 129, 130, 1, 0, 131, 132, 1, 0, 134,
		135, 1, 0, 137, 139, 1, 0, 142, 143, 1, 0, 55, 56, 2, 0, 30, 30, 37, 37,
		2, 0, 31, 31, 40, 40, 16, 0, 1, 10, 12, 13, 18, 21, 24, 25, 27, 29, 34,
		36, 39, 39, 41, 64, 71, 74, 76, 99, 102, 108, 110, 111, 115, 116, 118,
		130, 133, 146, 150, 152, 19, 0, 19, 19, 21, 21, 24, 25, 34, 36, 39, 39,
		41, 41, 43, 46, 52, 64, 72, 72, 79, 86, 90, 99, 104, 104, 108, 108, 110,
		111, 118, 126, 133, 136, 139, 140, 142, 144, 151, 152, 19, 0, 1, 10, 12,
		13, 18, 18, 20, 20, 27, 29, 42, 42, 47, 51, 71, 71, 73, 74, 76, 78, 87,
		89, 102, 103, 105, 107, 115, 116, 127, 130, 137, 138, 141, 141, 145, 146,
		150, 150, 11, 0, 2, 2, 18, 18, 20, 20, 42, 42, 44, 45, 53, 53, 59, 59,
		71, 71, 87, 89, 102, 103, 150, 152, 17, 0, 1, 10, 12, 13, 18, 21, 24, 25,
		27, 29, 34, 36, 39, 39, 41, 64, 71, 74, 76, 99, 102, 108, 110, 111, 115,
		116, 118, 130, 134, 135, 137, 146, 150, 152, 2, 0, 87, 88, 151, 152, 2,
		0, 154, 154, 157, 158, 1264, 0, 203, 1, 0, 0, 0, 2, 255, 1, 0, 0, 0, 4,
		261, 1, 0, 0, 0, 6, 267, 1, 0, 0, 0, 8, 277, 1, 0, 0, 0, 10, 279, 1, 0,
		0, 0, 12, 282, 1, 0, 0, 0, 14, 294, 1, 0, 0, 0, 16, 305, 1, 0, 0, 0, 18,
		318, 1, 0, 0, 0, 20, 333, 1, 0, 0, 0, 22, 337, 1, 0, 0, 0, 24, 340, 1,
		0, 0, 0, 26, 352, 1, 0, 0, 0, 28, 373, 1, 0, 0, 0, 30, 377, 1, 0, 0, 0,
		32, 379, 1, 0, 0, 0, 34, 381, 1, 0, 0, 0, 36, 383, 1, 0, 0, 0, 38, 390,
		1, 0, 0, 0, 40, 397, 1, 0, 0, 0, 42, 402, 1, 0, 0, 0, 44, 404, 1, 0, 0,
		0, 46, 409, 1, 0, 0, 0, 48, 414, 1, 0, 0, 0, 50, 426, 1, 0, 0, 0, 52, 429,
		1, 0, 0, 0, 54, 444, 1, 0, 0, 0, 56, 446, 1, 0, 0, 0, 58, 454, 1, 0, 0,
		0, 60, 462, 1, 0, 0, 0, 62, 489, 1, 0, 0, 0, 64, 492, 1, 0, 0, 0, 66, 500,
		1, 0, 0, 0, 68, 502, 1, 0, 0, 0, 70, 505, 1, 0, 0, 0, 72, 509, 1, 0, 0,
		0, 74, 511, 1, 0, 0, 0, 76, 516, 1, 0, 0, 0, 78, 521, 1, 0, 0, 0, 80, 539,
		1, 0, 0, 0, 82, 541, 1, 0, 0, 0, 84, 545, 1, 0, 0, 0, 86, 547, 1, 0, 0,
		0, 88, 549, 1, 0, 0, 0, 90, 569, 1, 0, 0, 0, 92, 579, 1, 0, 0, 0, 94, 588,
		1, 0, 0, 0, 96, 592, 1, 0, 0, 0, 98, 595, 1, 0, 0, 0, 100, 601, 1, 0, 0,
		0, 102, 614, 1, 0, 0, 0, 104, 616, 1, 0, 0, 0, 106, 625, 1, 0, 0, 0, 108,
		635, 1, 0, 0, 0, 110, 640, 1, 0, 0, 0, 112, 642, 1, 0, 0, 0, 114, 658,
		1, 0, 0, 0, 116, 691, 1, 0, 0, 0, 118, 744, 1, 0, 0, 0, 120, 750, 1, 0,
		0, 0, 122, 752, 1, 0, 0, 0, 124, 832, 1, 0, 0, 0, 126, 856, 1, 0, 0, 0,
		128, 861, 1, 0, 0, 0, 130, 864, 1, 0, 0, 0, 132, 866, 1, 0, 0, 0, 134,
		868, 1, 0, 0, 0, 136, 877, 1, 0, 0, 0, 138, 887, 1, 0, 0, 0, 140, 970,
		1, 0, 0, 0, 142, 985, 1, 0, 0, 0, 144, 989, 1, 0, 0, 0, 146, 991, 1, 0,
		0, 0, 148, 1003, 1, 0, 0, 0, 150, 1005, 1, 0, 0, 0, 152, 1012, 1, 0, 0,
		0, 154, 1024, 1, 0, 0, 0, 156, 1026, 1, 0, 0, 0, 158, 1034, 1, 0, 0, 0,
		160, 1050, 1, 0, 0, 0, 162, 1054, 1, 0, 0, 0, 164, 1069, 1, 0, 0, 0, 166,
		1080, 1, 0, 0, 0, 168, 1095, 1, 0, 0, 0, 170, 1098, 1, 0, 0, 0, 172, 1105,
		1, 0, 0, 0, 174, 1119, 1, 0, 0, 0, 176, 1121, 1, 0, 0, 0, 178, 1123, 1,
		0, 0, 0, 180, 1125, 1, 0, 0, 0, 182, 1127, 1, 0, 0, 0, 184, 1129, 1, 0,
		0, 0, 186, 1133, 1, 0, 0, 0, 188, 1137, 1, 0, 0, 0, 190, 1141, 1, 0, 0,
		0, 192, 1143, 1, 0, 0, 0, 194, 1145, 1, 0, 0, 0, 196, 1150, 1, 0, 0, 0,
		198, 1158, 1, 0, 0, 0, 200, 1165, 1, 0, 0, 0, 202, 204, 3, 2, 1, 0, 203,
		202, 1, 0, 0, 0, 203, 204, 1, 0, 0, 0, 204, 208, 1, 0, 0, 0, 205, 207,
		3, 4, 2, 0, 206, 205, 1, 0, 0, 0, 207, 210, 1, 0, 0, 0, 208, 206, 1, 0,
		0, 0, 208, 209, 1, 0, 0, 0, 209, 214, 1, 0, 0, 0, 210, 208, 1, 0, 0, 0,
		211, 213, 3, 6, 3, 0, 212, 211, 1, 0, 0, 0, 213, 216, 1, 0, 0, 0, 214,
		212, 1, 0, 0, 0, 214, 215, 1, 0, 0, 0, 215, 220, 1, 0, 0, 0, 216, 214,
		1, 0, 0, 0, 217, 219, 3, 14, 7, 0, 218, 217, 1, 0, 0, 0, 219, 222, 1, 0,
		0, 0, 220, 218, 1, 0, 0, 0, 220, 221, 1, 0, 0, 0, 221, 226, 1, 0, 0, 0,
		222, 220, 1, 0, 0, 0, 223, 225, 3, 16, 8, 0, 224, 223, 1, 0, 0, 0, 225,
		228, 1, 0, 0, 0, 226, 224, 1, 0, 0, 0, 226, 227, 1, 0, 0, 0, 227, 232,
		1, 0, 0, 0, 228, 226, 1, 0, 0, 0, 229, 231, 3, 24, 12, 0, 230, 229, 1,
		0, 0, 0, 231, 234, 1, 0, 0, 0, 232, 230, 1, 0, 0, 0, 232, 233, 1, 0, 0,
		0, 233, 238, 1, 0, 0, 0, 234, 232, 1, 0, 0, 0, 235, 237, 3, 26, 13, 0,
		236, 235, 1, 0, 0, 0, 237, 240, 1, 0, 0, 0, 238, 236, 1, 0, 0, 0, 238,
		239, 1, 0, 0, 0, 239, 244, 1, 0, 0, 0, 240, 238, 1, 0, 0, 0, 241, 243,
		3, 12, 6, 0, 242, 241, 1, 0, 0, 0, 243, 246, 1, 0, 0, 0, 244, 242, 1, 0,
		0, 0, 244, 245, 1, 0, 0, 0, 245, 250, 1, 0, 0, 0, 246, 244, 1, 0, 0, 0,
		247, 249, 3, 54, 27, 0, 248, 247, 1, 0, 0, 0, 249, 252, 1, 0, 0, 0, 250,
		248, 1, 0, 0, 0, 250, 251, 1, 0, 0, 0, 251, 253, 1, 0, 0, 0, 252, 250,
		1, 0, 0, 0, 253, 254, 5, 0, 0, 1, 254, 1, 1, 0, 0, 0, 255, 256, 5, 1, 0,
		0, 256, 259, 3, 106, 53, 0, 257, 258, 5, 2, 0, 0, 258, 260, 3, 34, 17,
		0, 259, 257, 1, 0, 0, 0, 259, 260, 1, 0, 0, 0, 260, 3, 1, 0, 0, 0, 261,
		262, 5, 3, 0, 0, 262, 265, 3, 42, 21, 0, 263, 264, 5, 2, 0, 0, 264, 266,
		3, 34, 17, 0, 265, 263, 1, 0, 0, 0, 265, 266, 1, 0, 0, 0, 266, 5, 1, 0,
		0, 0, 267, 268, 5, 4, 0, 0, 268, 271, 3, 106, 53, 0, 269, 270, 5, 2, 0,
		0, 270, 272, 3, 34, 17, 0, 271, 269, 1, 0, 0, 0, 271, 272, 1, 0, 0, 0,
		272, 275, 1, 0, 0, 0, 273, 274, 5, 5, 0, 0, 274, 276, 3, 8, 4, 0, 275,
		273, 1, 0, 0, 0, 275, 276, 1, 0, 0, 0, 276, 7, 1, 0, 0, 0, 277, 278, 3,
		192, 96, 0, 278, 9, 1, 0, 0, 0, 279, 280, 7, 0, 0, 0, 280, 11, 1, 0, 0,
		0, 281, 283, 3, 10, 5, 0, 282, 281, 1, 0, 0, 0, 282, 283, 1, 0, 0, 0, 283,
		284, 1, 0, 0, 0, 284, 285, 5, 8, 0, 0, 285, 287, 3, 192, 96, 0, 286, 288,
		3, 38, 19, 0, 287, 286, 1, 0, 0, 0, 287, 288, 1, 0, 0, 0, 288, 291, 1,
		0, 0, 0, 289, 290, 5, 9, 0, 0, 290, 292, 3, 116, 58, 0, 291, 289, 1, 0,
		0, 0, 291, 292, 1, 0, 0, 0, 292, 13, 1, 0, 0, 0, 293, 295, 3, 10, 5, 0,
		294, 293, 1, 0, 0, 0, 294, 295, 1, 0, 0, 0, 295, 296, 1, 0, 0, 0, 296,
		297, 5, 10, 0, 0, 297, 298, 3, 192, 96, 0, 298, 299, 5, 11, 0, 0, 299,
		302, 3, 30, 15, 0, 300, 301, 5, 2, 0, 0, 301, 303, 3, 34, 17, 0, 302, 300,
		1, 0, 0, 0, 302, 303, 1, 0, 0, 0, 303, 15, 1, 0, 0, 0, 304, 306, 3, 10,
		5, 0, 305, 304, 1, 0, 0, 0, 305, 306, 1, 0, 0, 0, 306, 307, 1, 0, 0, 0,
		307, 308, 5, 12, 0, 0, 308, 309, 3, 192, 96, 0, 309, 310, 5, 11, 0, 0,
		310, 313, 3, 32, 16, 0, 311, 312, 5, 2, 0, 0, 312, 314, 3, 34, 17, 0, 313,
		311, 1, 0, 0, 0, 313, 314, 1, 0, 0, 0, 314, 316, 1, 0, 0, 0, 315, 317,
		3, 18, 9, 0, 316, 315, 1, 0, 0, 0, 316, 317, 1, 0, 0, 0, 317, 17, 1, 0,
		0, 0, 318, 319, 5, 13, 0, 0, 319, 320, 5, 14, 0, 0, 320, 325, 3, 20, 10,
		0, 321, 322, 5, 15, 0, 0, 322, 324, 3, 20, 10, 0, 323, 321, 1, 0, 0, 0,
		324, 327, 1, 0, 0, 0, 325, 323, 1, 0, 0, 0, 325, 326, 1, 0, 0, 0, 326,
		328, 1, 0, 0, 0, 327, 325, 1, 0, 0, 0, 328, 329, 5, 16, 0, 0, 329, 19,
		1, 0, 0, 0, 330, 331, 3, 22, 11, 0, 331, 332, 5, 17, 0, 0, 332, 334, 1,
		0, 0, 0, 333, 330, 1, 0, 0, 0, 333, 334, 1, 0, 0, 0, 334, 335, 1, 0, 0,
		0, 335, 336, 3, 192, 96, 0, 336, 21, 1, 0, 0, 0, 337, 338, 3, 192, 96,
		0, 338, 23, 1, 0, 0, 0, 339, 341, 3, 10, 5, 0, 340, 339, 1, 0, 0, 0, 340,
		341, 1, 0, 0, 0, 341, 342, 1, 0, 0, 0, 342, 343, 5, 18, 0, 0, 343, 344,
		3, 192, 96, 0, 344, 345, 5, 11, 0, 0, 345, 346, 3, 36, 18, 0, 346, 347,
		5, 19, 0, 0, 347, 349, 3, 20, 10, 0, 348, 350, 3, 168, 84, 0, 349, 348,
		1, 0, 0, 0, 349, 350, 1, 0, 0, 0, 350, 25, 1, 0, 0, 0, 351, 353, 3, 10,
		5, 0, 352, 351, 1, 0, 0, 0, 352, 353, 1, 0, 0, 0, 353, 354, 1, 0, 0, 0,
		354, 355, 5, 20, 0, 0, 355, 356, 3, 192, 96, 0, 356, 357, 5, 11, 0, 0,
		357, 358, 5, 14, 0, 0, 358, 363, 3, 28, 14, 0, 359, 360, 5, 15, 0, 0, 360,
		362, 3, 28, 14, 0, 361, 359, 1, 0, 0, 0, 362, 365, 1, 0, 0, 0, 363, 361,
		1, 0, 0, 0, 363, 364, 1, 0, 0, 0, 364, 366, 1, 0, 0, 0, 365, 363, 1, 0,
		0, 0, 366, 368, 5, 16, 0, 0, 367, 369, 3, 168, 84, 0, 368, 367, 1, 0, 0,
		0, 368, 369, 1, 0, 0, 0, 369, 27, 1, 0, 0, 0, 370, 371, 3, 22, 11, 0, 371,
		372, 5, 17, 0, 0, 372, 374, 1, 0, 0, 0, 373, 370, 1, 0, 0, 0, 373, 374,
		1, 0, 0, 0, 374, 375, 1, 0, 0, 0, 375, 376, 3, 192, 96, 0, 376, 29, 1,
		0, 0, 0, 377, 378, 5, 159, 0, 0, 378, 31, 1, 0, 0, 0, 379, 380, 5, 159,
		0, 0, 380, 33, 1, 0, 0, 0, 381, 382, 5, 159, 0, 0, 382, 35, 1, 0, 0, 0,
		383, 384, 5, 159, 0, 0, 384, 37, 1, 0, 0, 0, 385, 391, 3, 40, 20, 0, 386,
		391, 3, 44, 22, 0, 387, 391, 3, 46, 23, 0, 388, 391, 3, 48, 24, 0, 389,
		391, 3, 52, 26, 0, 390, 385, 1, 0, 0, 0, 390, 386, 1, 0, 0, 0, 390, 387,
		1, 0, 0, 0, 390, 388, 1, 0, 0, 0, 390, 389, 1, 0, 0, 0, 391, 39, 1, 0,
		0, 0, 392, 393, 3, 86, 43, 0, 393, 394, 5, 17, 0, 0, 394, 396, 1, 0, 0,
		0, 395, 392, 1, 0, 0, 0, 396, 399, 1, 0, 0, 0, 397, 395, 1, 0, 0, 0, 397,
		398, 1, 0, 0, 0, 398, 400, 1, 0, 0, 0, 399, 397, 1, 0, 0, 0, 400, 401,
		3, 188, 94, 0, 401, 41, 1, 0, 0, 0, 402, 403, 3, 192, 96, 0, 403, 43, 1,
		0, 0, 0, 404, 405, 5, 21, 0, 0, 405, 406, 5, 22, 0, 0, 406, 407, 3, 38,
		19, 0, 407, 408, 5, 23, 0, 0, 408, 45, 1, 0, 0, 0, 409, 410, 5, 24, 0,
		0, 410, 411, 5, 22, 0, 0, 411, 412, 3, 38, 19, 0, 412, 413, 5, 23, 0, 0,
		413, 47, 1, 0, 0, 0, 414, 415, 5, 25, 0, 0, 415, 416, 5, 14, 0, 0, 416,
		421, 3, 50, 25, 0, 417, 418, 5, 15, 0, 0, 418, 420, 3, 50, 25, 0, 419,
		417, 1, 0, 0, 0, 420, 423, 1, 0, 0, 0, 421, 419, 1, 0, 0, 0, 421, 422,
		1, 0, 0, 0, 422, 424, 1, 0, 0, 0, 423, 421, 1, 0, 0, 0, 424, 425, 5, 16,
		0, 0, 425, 49, 1, 0, 0, 0, 426, 427, 3, 186, 93, 0, 427, 428, 3, 38, 19,
		0, 428, 51, 1, 0, 0, 0, 429, 430, 5, 26, 0, 0, 430, 431, 5, 22, 0, 0, 431,
		436, 3, 38, 19, 0, 432, 433, 5, 15, 0, 0, 433, 435, 3, 38, 19, 0, 434,
		432, 1, 0, 0, 0, 435, 438, 1, 0, 0, 0, 436, 434, 1, 0, 0, 0, 436, 437,
		1, 0, 0, 0, 437, 439, 1, 0, 0, 0, 438, 436, 1, 0, 0, 0, 439, 440, 5, 23,
		0, 0, 440, 53, 1, 0, 0, 0, 441, 445, 3, 56, 28, 0, 442, 445, 3, 58, 29,
		0, 443, 445, 3, 60, 30, 0, 444, 441, 1, 0, 0, 0, 444, 442, 1, 0, 0, 0,
		444, 443, 1, 0, 0, 0, 445, 55, 1, 0, 0, 0, 446, 448, 5, 27, 0, 0, 447,
		449, 3, 10, 5, 0, 448, 447, 1, 0, 0, 0, 448, 449, 1, 0, 0, 0, 449, 450,
		1, 0, 0, 0, 450, 451, 3, 192, 96, 0, 451, 452, 5, 11, 0, 0, 452, 453, 3,
		116, 58, 0, 453, 57, 1, 0, 0, 0, 454, 458, 5, 28, 0, 0, 455, 456, 3, 42,
		21, 0, 456, 457, 5, 17, 0, 0, 457, 459, 1, 0, 0, 0, 458, 455, 1, 0, 0,
		0, 458, 459, 1, 0, 0, 0, 459, 460, 1, 0, 0, 0, 460, 461, 3, 192, 96, 0,
		461, 59, 1, 0, 0, 0, 462, 464, 5, 27, 0, 0, 463, 465, 3, 10, 5, 0, 464,
		463, 1, 0, 0, 0, 464, 465, 1, 0, 0, 0, 465, 466, 1, 0, 0, 0, 466, 467,
		5, 29, 0, 0, 467, 468, 3, 190, 95, 0, 468, 477, 5, 30, 0, 0, 469, 474,
		3, 62, 31, 0, 470, 471, 5, 15, 0, 0, 471, 473, 3, 62, 31, 0, 472, 470,
		1, 0, 0, 0, 473, 476, 1, 0, 0, 0, 474, 472, 1, 0, 0, 0, 474, 475, 1, 0,
		0, 0, 475, 478, 1, 0, 0, 0, 476, 474, 1, 0, 0, 0, 477, 469, 1, 0, 0, 0,
		477, 478, 1, 0, 0, 0, 478, 479, 1, 0, 0, 0, 479, 482, 5, 31, 0, 0, 480,
		481, 5, 32, 0, 0, 481, 483, 3, 38, 19, 0, 482, 480, 1, 0, 0, 0, 482, 483,
		1, 0, 0, 0, 483, 484, 1, 0, 0, 0, 484, 487, 5, 11, 0, 0, 485, 488, 3, 64,
		32, 0, 486, 488, 5, 33, 0, 0, 487, 485, 1, 0, 0, 0, 487, 486, 1, 0, 0,
		0, 488, 61, 1, 0, 0, 0, 489, 490, 3, 186, 93, 0, 490, 491, 3, 38, 19, 0,
		491, 63, 1, 0, 0, 0, 492, 493, 3, 116, 58, 0, 493, 65, 1, 0, 0, 0, 494,
		501, 3, 78, 39, 0, 495, 501, 3, 108, 54, 0, 496, 497, 5, 30, 0, 0, 497,
		498, 3, 116, 58, 0, 498, 499, 5, 31, 0, 0, 499, 501, 1, 0, 0, 0, 500, 494,
		1, 0, 0, 0, 500, 495, 1, 0, 0, 0, 500, 496, 1, 0, 0, 0, 501, 67, 1, 0,
		0, 0, 502, 503, 3, 66, 33, 0, 503, 504, 3, 70, 35, 0, 504, 69, 1, 0, 0,
		0, 505, 506, 3, 192, 96, 0, 506, 71, 1, 0, 0, 0, 507, 510, 3, 74, 37, 0,
		508, 510, 3, 76, 38, 0, 509, 507, 1, 0, 0, 0, 509, 508, 1, 0, 0, 0, 510,
		73, 1, 0, 0, 0, 511, 512, 5, 34, 0, 0, 512, 513, 3, 68, 34, 0, 513, 514,
		5, 35, 0, 0, 514, 515, 3, 116, 58, 0, 515, 75, 1, 0, 0, 0, 516, 517, 5,
		36, 0, 0, 517, 518, 3, 68, 34, 0, 518, 519, 5, 35, 0, 0, 519, 520, 3, 116,
		58, 0, 520, 77, 1, 0, 0, 0, 521, 525, 5, 37, 0, 0, 522, 523, 3, 80, 40,
		0, 523, 524, 5, 38, 0, 0, 524, 526, 1, 0, 0, 0, 525, 522, 1, 0, 0, 0, 525,
		526, 1, 0, 0, 0, 526, 527, 1, 0, 0, 0, 527, 535, 3, 40, 20, 0, 528, 532,
		5, 11, 0, 0, 529, 530, 3, 82, 41, 0, 530, 531, 5, 39, 0, 0, 531, 533, 1,
		0, 0, 0, 532, 529, 1, 0, 0, 0, 532, 533, 1, 0, 0, 0, 533, 534, 1, 0, 0,
		0, 534, 536, 3, 84, 42, 0, 535, 528, 1, 0, 0, 0, 535, 536, 1, 0, 0, 0,
		536, 537, 1, 0, 0, 0, 537, 538, 5, 40, 0, 0, 538, 79, 1, 0, 0, 0, 539,
		540, 3, 108, 54, 0, 540, 81, 1, 0, 0, 0, 541, 542, 3, 112, 56, 0, 542,
		83, 1, 0, 0, 0, 543, 546, 3, 108, 54, 0, 544, 546, 3, 116, 58, 0, 545,
		543, 1, 0, 0, 0, 545, 544, 1, 0, 0, 0, 546, 85, 1, 0, 0, 0, 547, 548, 3,
		192, 96, 0, 548, 87, 1, 0, 0, 0, 549, 551, 3, 90, 45, 0, 550, 552, 3, 92,
		46, 0, 551, 550, 1, 0, 0, 0, 551, 552, 1, 0, 0, 0, 552, 556, 1, 0, 0, 0,
		553, 555, 3, 72, 36, 0, 554, 553, 1, 0, 0, 0, 555, 558, 1, 0, 0, 0, 556,
		554, 1, 0, 0, 0, 556, 557, 1, 0, 0, 0, 557, 560, 1, 0, 0, 0, 558, 556,
		1, 0, 0, 0, 559, 561, 3, 96, 48, 0, 560, 559, 1, 0, 0, 0, 560, 561, 1,
		0, 0, 0, 561, 563, 1, 0, 0, 0, 562, 564, 3, 98, 49, 0, 563, 562, 1, 0,
		0, 0, 563, 564, 1, 0, 0, 0, 564, 566, 1, 0, 0, 0, 565, 567, 3, 100, 50,
		0, 566, 565, 1, 0, 0, 0, 566, 567, 1, 0, 0, 0, 567, 89, 1, 0, 0, 0, 568,
		570, 5, 19, 0, 0, 569, 568, 1, 0, 0, 0, 569, 570, 1, 0, 0, 0, 570, 571,
		1, 0, 0, 0, 571, 576, 3, 68, 34, 0, 572, 573, 5, 15, 0, 0, 573, 575, 3,
		68, 34, 0, 574, 572, 1, 0, 0, 0, 575, 578, 1, 0, 0, 0, 576, 574, 1, 0,
		0, 0, 576, 577, 1, 0, 0, 0, 577, 91, 1, 0, 0, 0, 578, 576, 1, 0, 0, 0,
		579, 580, 5, 41, 0, 0, 580, 585, 3, 94, 47, 0, 581, 582, 5, 15, 0, 0, 582,
		584, 3, 94, 47, 0, 583, 581, 1, 0, 0, 0, 584, 587, 1, 0, 0, 0, 585, 583,
		1, 0, 0, 0, 585, 586, 1, 0, 0, 0, 586, 93, 1, 0, 0, 0, 587, 585, 1, 0,
		0, 0, 588, 589, 3, 192, 96, 0, 589, 590, 5, 11, 0, 0, 590, 591, 3, 116,
		58, 0, 591, 95, 1, 0, 0, 0, 592, 593, 5, 42, 0, 0, 593, 594, 3, 116, 58,
		0, 594, 97, 1, 0, 0, 0, 595, 597, 5, 43, 0, 0, 596, 598, 7, 1, 0, 0, 597,
		596, 1, 0, 0, 0, 597, 598, 1, 0, 0, 0, 598, 599, 1, 0, 0, 0, 599, 600,
		3, 116, 58, 0, 600, 99, 1, 0, 0, 0, 601, 612, 5, 46, 0, 0, 602, 613, 3,
		102, 51, 0, 603, 604, 5, 47, 0, 0, 604, 609, 3, 104, 52, 0, 605, 606, 5,
		15, 0, 0, 606, 608, 3, 104, 52, 0, 607, 605, 1, 0, 0, 0, 608, 611, 1, 0,
		0, 0, 609, 607, 1, 0, 0, 0, 609, 610, 1, 0, 0, 0, 610, 613, 1, 0, 0, 0,
		611, 609, 1, 0, 0, 0, 612, 602, 1, 0, 0, 0, 612, 603, 1, 0, 0, 0, 613,
		101, 1, 0, 0, 0, 614, 615, 7, 2, 0, 0, 615, 103, 1, 0, 0, 0, 616, 618,
		3, 124, 62, 0, 617, 619, 3, 102, 51, 0, 618, 617, 1, 0, 0, 0, 618, 619,
		1, 0, 0, 0, 619, 105, 1, 0, 0, 0, 620, 621, 3, 86, 43, 0, 621, 622, 5,
		17, 0, 0, 622, 624, 1, 0, 0, 0, 623, 620, 1, 0, 0, 0, 624, 627, 1, 0, 0,
		0, 625, 623, 1, 0, 0, 0, 625, 626, 1, 0, 0, 0, 626, 628, 1, 0, 0, 0, 627,
		625, 1, 0, 0, 0, 628, 629, 3, 192, 96, 0, 629, 107, 1, 0, 0, 0, 630, 631,
		3, 110, 55, 0, 631, 632, 5, 17, 0, 0, 632, 634, 1, 0, 0, 0, 633, 630, 1,
		0, 0, 0, 634, 637, 1, 0, 0, 0, 635, 633, 1, 0, 0, 0, 635, 636, 1, 0, 0,
		0, 636, 638, 1, 0, 0, 0, 637, 635, 1, 0, 0, 0, 638, 639, 3, 186, 93, 0,
		639, 109, 1, 0, 0, 0, 640, 641, 3, 186, 93, 0, 641, 111, 1, 0, 0, 0, 642,
		643, 6, 56, -1, 0, 643, 644, 3, 186, 93, 0, 644, 655, 1, 0, 0, 0, 645,
		646, 10, 2, 0, 0, 646, 647, 5, 17, 0, 0, 647, 654, 3, 186, 93, 0, 648,
		649, 10, 1, 0, 0, 649, 650, 5, 37, 0, 0, 650, 651, 3, 114, 57, 0, 651,
		652, 5, 40, 0, 0, 652, 654, 1, 0, 0, 0, 653, 645, 1, 0, 0, 0, 653, 648,
		1, 0, 0, 0, 654, 657, 1, 0, 0, 0, 655, 653, 1, 0, 0, 0, 655, 656, 1, 0,
		0, 0, 656, 113, 1, 0, 0, 0, 657, 655, 1, 0, 0, 0, 658, 659, 7, 3, 0, 0,
		659, 115, 1, 0, 0, 0, 660, 661, 6, 58, -1, 0, 661, 692, 3, 124, 62, 0,
		662, 692, 3, 78, 39, 0, 663, 692, 3, 88, 44, 0, 664, 665, 5, 58, 0, 0,
		665, 666, 3, 116, 58, 0, 666, 667, 5, 57, 0, 0, 667, 668, 3, 38, 19, 0,
		668, 692, 1, 0, 0, 0, 669, 670, 5, 53, 0, 0, 670, 692, 3, 116, 58, 13,
		671, 672, 5, 59, 0, 0, 672, 692, 3, 116, 58, 12, 673, 674, 5, 63, 0, 0,
		674, 676, 5, 39, 0, 0, 675, 673, 1, 0, 0, 0, 675, 676, 1, 0, 0, 0, 676,
		677, 1, 0, 0, 0, 677, 678, 3, 122, 61, 0, 678, 679, 5, 61, 0, 0, 679, 680,
		3, 124, 62, 0, 680, 681, 5, 62, 0, 0, 681, 682, 3, 124, 62, 0, 682, 692,
		1, 0, 0, 0, 683, 684, 5, 64, 0, 0, 684, 685, 5, 39, 0, 0, 685, 686, 3,
		122, 61, 0, 686, 687, 5, 61, 0, 0, 687, 688, 3, 124, 62, 0, 688, 689, 5,
		62, 0, 0, 689, 690, 3, 124, 62, 0, 690, 692, 1, 0, 0, 0, 691, 660, 1, 0,
		0, 0, 691, 662, 1, 0, 0, 0, 691, 663, 1, 0, 0, 0, 691, 664, 1, 0, 0, 0,
		691, 669, 1, 0, 0, 0, 691, 671, 1, 0, 0, 0, 691, 675, 1, 0, 0, 0, 691,
		683, 1, 0, 0, 0, 692, 741, 1, 0, 0, 0, 693, 694, 10, 8, 0, 0, 694, 695,
		7, 4, 0, 0, 695, 740, 3, 116, 58, 9, 696, 697, 10, 7, 0, 0, 697, 698, 3,
		140, 70, 0, 698, 699, 3, 116, 58, 8, 699, 740, 1, 0, 0, 0, 700, 701, 10,
		6, 0, 0, 701, 702, 7, 5, 0, 0, 702, 740, 3, 116, 58, 7, 703, 704, 10, 5,
		0, 0, 704, 706, 7, 6, 0, 0, 705, 707, 3, 128, 64, 0, 706, 705, 1, 0, 0,
		0, 706, 707, 1, 0, 0, 0, 707, 708, 1, 0, 0, 0, 708, 740, 3, 116, 58, 6,
		709, 710, 10, 4, 0, 0, 710, 711, 5, 62, 0, 0, 711, 740, 3, 116, 58, 5,
		712, 713, 10, 3, 0, 0, 713, 714, 7, 7, 0, 0, 714, 740, 3, 116, 58, 4, 715,
		716, 10, 2, 0, 0, 716, 717, 5, 74, 0, 0, 717, 740, 3, 116, 58, 3, 718,
		719, 10, 1, 0, 0, 719, 720, 7, 8, 0, 0, 720, 740, 3, 116, 58, 2, 721, 722,
		10, 16, 0, 0, 722, 724, 5, 52, 0, 0, 723, 725, 5, 53, 0, 0, 724, 723, 1,
		0, 0, 0, 724, 725, 1, 0, 0, 0, 725, 726, 1, 0, 0, 0, 726, 740, 7, 9, 0,
		0, 727, 728, 10, 15, 0, 0, 728, 729, 7, 10, 0, 0, 729, 740, 3, 38, 19,
		0, 730, 732, 10, 11, 0, 0, 731, 733, 5, 60, 0, 0, 732, 731, 1, 0, 0, 0,
		732, 733, 1, 0, 0, 0, 733, 734, 1, 0, 0, 0, 734, 735, 5, 61, 0, 0, 735,
		736, 3, 124, 62, 0, 736, 737, 5, 62, 0, 0, 737, 738, 3, 124, 62, 0, 738,
		740, 1, 0, 0, 0, 739, 693, 1, 0, 0, 0, 739, 696, 1, 0, 0, 0, 739, 700,
		1, 0, 0, 0, 739, 703, 1, 0, 0, 0, 739, 709, 1, 0, 0, 0, 739, 712, 1, 0,
		0, 0, 739, 715, 1, 0, 0, 0, 739, 718, 1, 0, 0, 0, 739, 721, 1, 0, 0, 0,
		739, 727, 1, 0, 0, 0, 739, 730, 1, 0, 0, 0, 740, 743, 1, 0, 0, 0, 741,
		739, 1, 0, 0, 0, 741, 742, 1, 0, 0, 0, 742, 117, 1, 0, 0, 0, 743, 741,
		1, 0, 0, 0, 744, 745, 7, 11, 0, 0, 745, 119, 1, 0, 0, 0, 746, 751, 3, 118,
		59, 0, 747, 751, 5, 87, 0, 0, 748, 751, 5, 88, 0, 0, 749, 751, 5, 89, 0,
		0, 750, 746, 1, 0, 0, 0, 750, 747, 1, 0, 0, 0, 750, 748, 1, 0, 0, 0, 750,
		749, 1, 0, 0, 0, 751, 121, 1, 0, 0, 0, 752, 753, 7, 12, 0, 0, 753, 123,
		1, 0, 0, 0, 754, 755, 6, 62, -1, 0, 755, 833, 3, 142, 71, 0, 756, 757,
		5, 98, 0, 0, 757, 758, 3, 116, 58, 0, 758, 761, 5, 99, 0, 0, 759, 762,
		3, 38, 19, 0, 760, 762, 3, 200, 100, 0, 761, 759, 1, 0, 0, 0, 761, 760,
		1, 0, 0, 0, 762, 833, 1, 0, 0, 0, 763, 764, 7, 13, 0, 0, 764, 833, 3, 124,
		62, 18, 765, 766, 7, 14, 0, 0, 766, 767, 5, 104, 0, 0, 767, 833, 3, 124,
		62, 17, 768, 769, 3, 120, 60, 0, 769, 770, 5, 19, 0, 0, 770, 771, 3, 124,
		62, 16, 771, 833, 1, 0, 0, 0, 772, 773, 5, 63, 0, 0, 773, 774, 5, 39, 0,
		0, 774, 775, 3, 122, 61, 0, 775, 776, 5, 104, 0, 0, 776, 777, 3, 124, 62,
		15, 777, 833, 1, 0, 0, 0, 778, 779, 5, 64, 0, 0, 779, 780, 5, 39, 0, 0,
		780, 781, 3, 122, 61, 0, 781, 782, 5, 104, 0, 0, 782, 783, 3, 124, 62,
		14, 783, 833, 1, 0, 0, 0, 784, 785, 5, 105, 0, 0, 785, 786, 5, 104, 0,
		0, 786, 833, 3, 124, 62, 13, 787, 788, 5, 106, 0, 0, 788, 789, 5, 104,
		0, 0, 789, 833, 3, 124, 62, 12, 790, 791, 5, 107, 0, 0, 791, 792, 5, 104,
		0, 0, 792, 833, 3, 124, 62, 11, 793, 794, 5, 108, 0, 0, 794, 795, 5, 19,
		0, 0, 795, 833, 3, 124, 62, 10, 796, 797, 5, 109, 0, 0, 797, 798, 5, 19,
		0, 0, 798, 833, 3, 124, 62, 9, 799, 800, 7, 15, 0, 0, 800, 833, 3, 40,
		20, 0, 801, 802, 5, 118, 0, 0, 802, 803, 3, 116, 58, 0, 803, 804, 5, 119,
		0, 0, 804, 805, 3, 116, 58, 0, 805, 806, 5, 120, 0, 0, 806, 807, 3, 116,
		58, 0, 807, 833, 1, 0, 0, 0, 808, 810, 5, 121, 0, 0, 809, 811, 3, 116,
		58, 0, 810, 809, 1, 0, 0, 0, 810, 811, 1, 0, 0, 0, 811, 813, 1, 0, 0, 0,
		812, 814, 3, 126, 63, 0, 813, 812, 1, 0, 0, 0, 814, 815, 1, 0, 0, 0, 815,
		813, 1, 0, 0, 0, 815, 816, 1, 0, 0, 0, 816, 817, 1, 0, 0, 0, 817, 818,
		5, 120, 0, 0, 818, 819, 3, 116, 58, 0, 819, 820, 5, 103, 0, 0, 820, 833,
		1, 0, 0, 0, 821, 822, 7, 16, 0, 0, 822, 833, 3, 116, 58, 0, 823, 824, 7,
		17, 0, 0, 824, 830, 3, 116, 58, 0, 825, 828, 5, 125, 0, 0, 826, 829, 3,
		118, 59, 0, 827, 829, 3, 116, 58, 0, 828, 826, 1, 0, 0, 0, 828, 827, 1,
		0, 0, 0, 829, 831, 1, 0, 0, 0, 830, 825, 1, 0, 0, 0, 830, 831, 1, 0, 0,
		0, 831, 833, 1, 0, 0, 0, 832, 754, 1, 0, 0, 0, 832, 756, 1, 0, 0, 0, 832,
		763, 1, 0, 0, 0, 832, 765, 1, 0, 0, 0, 832, 768, 1, 0, 0, 0, 832, 772,
		1, 0, 0, 0, 832, 778, 1, 0, 0, 0, 832, 784, 1, 0, 0, 0, 832, 787, 1, 0,
		0, 0, 832, 790, 1, 0, 0, 0, 832, 793, 1, 0, 0, 0, 832, 796, 1, 0, 0, 0,
		832, 799, 1, 0, 0, 0, 832, 801, 1, 0, 0, 0, 832, 808, 1, 0, 0, 0, 832,
		821, 1, 0, 0, 0, 832, 823, 1, 0, 0, 0, 833, 853, 1, 0, 0, 0, 834, 835,
		10, 7, 0, 0, 835, 836, 5, 112, 0, 0, 836, 852, 3, 124, 62, 8, 837, 838,
		10, 6, 0, 0, 838, 839, 7, 18, 0, 0, 839, 852, 3, 124, 62, 7, 840, 841,
		10, 5, 0, 0, 841, 842, 7, 19, 0, 0, 842, 852, 3, 124, 62, 6, 843, 844,
		10, 21, 0, 0, 844, 845, 5, 17, 0, 0, 845, 852, 3, 144, 72, 0, 846, 847,
		10, 20, 0, 0, 847, 848, 5, 37, 0, 0, 848, 849, 3, 116, 58, 0, 849, 850,
		5, 40, 0, 0, 850, 852, 1, 0, 0, 0, 851, 834, 1, 0, 0, 0, 851, 837, 1, 0,
		0, 0, 851, 840, 1, 0, 0, 0, 851, 843, 1, 0, 0, 0, 851, 846, 1, 0, 0, 0,
		852, 855, 1, 0, 0, 0, 853, 851, 1, 0, 0, 0, 853, 854, 1, 0, 0, 0, 854,
		125, 1, 0, 0, 0, 855, 853, 1, 0, 0, 0, 856, 857, 5, 126, 0, 0, 857, 858,
		3, 116, 58, 0, 858, 859, 5, 119, 0, 0, 859, 860, 3, 116, 58, 0, 860, 127,
		1, 0, 0, 0, 861, 862, 3, 118, 59, 0, 862, 863, 5, 104, 0, 0, 863, 129,
		1, 0, 0, 0, 864, 865, 7, 20, 0, 0, 865, 131, 1, 0, 0, 0, 866, 867, 7, 21,
		0, 0, 867, 133, 1, 0, 0, 0, 868, 869, 7, 22, 0, 0, 869, 135, 1, 0, 0, 0,
		870, 872, 3, 198, 99, 0, 871, 873, 3, 132, 66, 0, 872, 871, 1, 0, 0, 0,
		872, 873, 1, 0, 0, 0, 873, 878, 1, 0, 0, 0, 874, 875, 3, 134, 67, 0, 875,
		876, 3, 198, 99, 0, 876, 878, 1, 0, 0, 0, 877, 870, 1, 0, 0, 0, 877, 874,
		1, 0, 0, 0, 878, 137, 1, 0, 0, 0, 879, 881, 5, 133, 0, 0, 880, 879, 1,
		0, 0, 0, 880, 881, 1, 0, 0, 0, 881, 882, 1, 0, 0, 0, 882, 888, 7, 23, 0,
		0, 883, 885, 7, 23, 0, 0, 884, 886, 5, 136, 0, 0, 885, 884, 1, 0, 0, 0,
		885, 886, 1, 0, 0, 0, 886, 888, 1, 0, 0, 0, 887, 880, 1, 0, 0, 0, 887,
		883, 1, 0, 0, 0, 888, 139, 1, 0, 0, 0, 889, 891, 7, 24, 0, 0, 890, 889,
		1, 0, 0, 0, 890, 891, 1, 0, 0, 0, 891, 892, 1, 0, 0, 0, 892, 894, 5, 140,
		0, 0, 893, 895, 3, 118, 59, 0, 894, 893, 1, 0, 0, 0, 894, 895, 1, 0, 0,
		0, 895, 898, 1, 0, 0, 0, 896, 899, 3, 130, 65, 0, 897, 899, 5, 57, 0, 0,
		898, 896, 1, 0, 0, 0, 898, 897, 1, 0, 0, 0, 899, 901, 1, 0, 0, 0, 900,
		902, 7, 14, 0, 0, 901, 900, 1, 0, 0, 0, 901, 902, 1, 0, 0, 0, 902, 971,
		1, 0, 0, 0, 903, 905, 5, 60, 0, 0, 904, 903, 1, 0, 0, 0, 904, 905, 1, 0,
		0, 0, 905, 906, 1, 0, 0, 0, 906, 908, 5, 141, 0, 0, 907, 909, 3, 128, 64,
		0, 908, 907, 1, 0, 0, 0, 908, 909, 1, 0, 0, 0, 909, 911, 1, 0, 0, 0, 910,
		912, 7, 14, 0, 0, 911, 910, 1, 0, 0, 0, 911, 912, 1, 0, 0, 0, 912, 971,
		1, 0, 0, 0, 913, 915, 7, 24, 0, 0, 914, 913, 1, 0, 0, 0, 914, 915, 1, 0,
		0, 0, 915, 917, 1, 0, 0, 0, 916, 918, 5, 60, 0, 0, 917, 916, 1, 0, 0, 0,
		917, 918, 1, 0, 0, 0, 918, 919, 1, 0, 0, 0, 919, 921, 7, 25, 0, 0, 920,
		922, 3, 128, 64, 0, 921, 920, 1, 0, 0, 0, 921, 922, 1, 0, 0, 0, 922, 971,
		1, 0, 0, 0, 923, 925, 7, 24, 0, 0, 924, 923, 1, 0, 0, 0, 924, 925, 1, 0,
		0, 0, 925, 927, 1, 0, 0, 0, 926, 928, 3, 136, 68, 0, 927, 926, 1, 0, 0,
		0, 927, 928, 1, 0, 0, 0, 928, 929, 1, 0, 0, 0, 929, 931, 3, 138, 69, 0,
		930, 932, 3, 128, 64, 0, 931, 930, 1, 0, 0, 0, 931, 932, 1, 0, 0, 0, 932,
		934, 1, 0, 0, 0, 933, 935, 7, 14, 0, 0, 934, 933, 1, 0, 0, 0, 934, 935,
		1, 0, 0, 0, 935, 971, 1, 0, 0, 0, 936, 938, 7, 24, 0, 0, 937, 936, 1, 0,
		0, 0, 937, 938, 1, 0, 0, 0, 938, 940, 1, 0, 0, 0, 939, 941, 5, 60, 0, 0,
		940, 939, 1, 0, 0, 0, 940, 941, 1, 0, 0, 0, 941, 942, 1, 0, 0, 0, 942,
		943, 5, 144, 0, 0, 943, 944, 3, 198, 99, 0, 944, 946, 5, 104, 0, 0, 945,
		947, 7, 14, 0, 0, 946, 945, 1, 0, 0, 0, 946, 947, 1, 0, 0, 0, 947, 971,
		1, 0, 0, 0, 948, 950, 5, 145, 0, 0, 949, 951, 7, 23, 0, 0, 950, 949, 1,
		0, 0, 0, 950, 951, 1, 0, 0, 0, 951, 953, 1, 0, 0, 0, 952, 954, 3, 128,
		64, 0, 953, 952, 1, 0, 0, 0, 953, 954, 1, 0, 0, 0, 954, 971, 1, 0, 0, 0,
		955, 957, 5, 146, 0, 0, 956, 958, 7, 23, 0, 0, 957, 956, 1, 0, 0, 0, 957,
		958, 1, 0, 0, 0, 958, 960, 1, 0, 0, 0, 959, 961, 3, 128, 64, 0, 960, 959,
		1, 0, 0, 0, 960, 961, 1, 0, 0, 0, 961, 971, 1, 0, 0, 0, 962, 964, 5, 137,
		0, 0, 963, 965, 3, 128, 64, 0, 964, 963, 1, 0, 0, 0, 964, 965, 1, 0, 0,
		0, 965, 971, 1, 0, 0, 0, 966, 968, 5, 138, 0, 0, 967, 969, 3, 128, 64,
		0, 968, 967, 1, 0, 0, 0, 968, 969, 1, 0, 0, 0, 969, 971, 1, 0, 0, 0, 970,
		890, 1, 0, 0, 0, 970, 904, 1, 0, 0, 0, 970, 914, 1, 0, 0, 0, 970, 924,
		1, 0, 0, 0, 970, 937, 1, 0, 0, 0, 970, 948, 1, 0, 0, 0, 970, 955, 1, 0,
		0, 0, 970, 962, 1, 0, 0, 0, 970, 966, 1, 0, 0, 0, 971, 141, 1, 0, 0, 0,
		972, 986, 3, 148, 74, 0, 973, 986, 3, 154, 77, 0, 974, 986, 3, 194, 97,
		0, 975, 986, 3, 156, 78, 0, 976, 986, 3, 158, 79, 0, 977, 986, 3, 162,
		81, 0, 978, 986, 3, 166, 83, 0, 979, 986, 3, 170, 85, 0, 980, 986, 3, 172,
		86, 0, 981, 982, 5, 30, 0, 0, 982, 983, 3, 116, 58, 0, 983, 984, 5, 31,
		0, 0, 984, 986, 1, 0, 0, 0, 985, 972, 1, 0, 0, 0, 985, 973, 1, 0, 0, 0,
		985, 974, 1, 0, 0, 0, 985, 975, 1, 0, 0, 0, 985, 976, 1, 0, 0, 0, 985,
		977, 1, 0, 0, 0, 985, 978, 1, 0, 0, 0, 985, 979, 1, 0, 0, 0, 985, 980,
		1, 0, 0, 0, 985, 981, 1, 0, 0, 0, 986, 143, 1, 0, 0, 0, 987, 990, 3, 186,
		93, 0, 988, 990, 3, 146, 73, 0, 989, 987, 1, 0, 0, 0, 989, 988, 1, 0, 0,
		0, 990, 145, 1, 0, 0, 0, 991, 992, 3, 190, 95, 0, 992, 994, 5, 30, 0, 0,
		993, 995, 3, 196, 98, 0, 994, 993, 1, 0, 0, 0, 994, 995, 1, 0, 0, 0, 995,
		996, 1, 0, 0, 0, 996, 997, 5, 31, 0, 0, 997, 147, 1, 0, 0, 0, 998, 1004,
		3, 186, 93, 0, 999, 1004, 3, 150, 75, 0, 1000, 1004, 5, 147, 0, 0, 1001,
		1004, 5, 148, 0, 0, 1002, 1004, 5, 149, 0, 0, 1003, 998, 1, 0, 0, 0, 1003,
		999, 1, 0, 0, 0, 1003, 1000, 1, 0, 0, 0, 1003, 1001, 1, 0, 0, 0, 1003,
		1002, 1, 0, 0, 0, 1004, 149, 1, 0, 0, 0, 1005, 1006, 3, 186, 93, 0, 1006,
		1008, 5, 30, 0, 0, 1007, 1009, 3, 196, 98, 0, 1008, 1007, 1, 0, 0, 0, 1008,
		1009, 1, 0, 0, 0, 1009, 1010, 1, 0, 0, 0, 1010, 1011, 5, 31, 0, 0, 1011,
		151, 1, 0, 0, 0, 1012, 1013, 3, 198, 99, 0, 1013, 1014, 5, 11, 0, 0, 1014,
		1015, 3, 198, 99, 0, 1015, 153, 1, 0, 0, 0, 1016, 1025, 7, 26, 0, 0, 1017,
		1025, 5, 54, 0, 0, 1018, 1025, 5, 159, 0, 0, 1019, 1025, 5, 160, 0, 0,
		1020, 1025, 5, 155, 0, 0, 1021, 1025, 5, 156, 0, 0, 1022, 1025, 3, 198,
		99, 0, 1023, 1025, 3, 152, 76, 0, 1024, 1016, 1, 0, 0, 0, 1024, 1017, 1,
		0, 0, 0, 1024, 1018, 1, 0, 0, 0, 1024, 1019, 1, 0, 0, 0, 1024, 1020, 1,
		0, 0, 0, 1024, 1021, 1, 0, 0, 0, 1024, 1022, 1, 0, 0, 0, 1024, 1023, 1,
		0, 0, 0, 1025, 155, 1, 0, 0, 0, 1026, 1027, 5, 24, 0, 0, 1027, 1028, 7,
		27, 0, 0, 1028, 1029, 3, 116, 58, 0, 1029, 1030, 5, 15, 0, 0, 1030, 1031,
		3, 116, 58, 0, 1031, 1032, 7, 28, 0, 0, 1032, 157, 1, 0, 0, 0, 1033, 1035,
		5, 25, 0, 0, 1034, 1033, 1, 0, 0, 0, 1034, 1035, 1, 0, 0, 0, 1035, 1036,
		1, 0, 0, 0, 1036, 1046, 5, 14, 0, 0, 1037, 1047, 5, 11, 0, 0, 1038, 1043,
		3, 160, 80, 0, 1039, 1040, 5, 15, 0, 0, 1040, 1042, 3, 160, 80, 0, 1041,
		1039, 1, 0, 0, 0, 1042, 1045, 1, 0, 0, 0, 1043, 1041, 1, 0, 0, 0, 1043,
		1044, 1, 0, 0, 0, 1044, 1047, 1, 0, 0, 0, 1045, 1043, 1, 0, 0, 0, 1046,
		1037, 1, 0, 0, 0, 1046, 1038, 1, 0, 0, 0, 1047, 1048, 1, 0, 0, 0, 1048,
		1049, 5, 16, 0, 0, 1049, 159, 1, 0, 0, 0, 1050, 1051, 3, 186, 93, 0, 1051,
		1052, 5, 11, 0, 0, 1052, 1053, 3, 116, 58, 0, 1053, 161, 1, 0, 0, 0, 1054,
		1055, 3, 40, 20, 0, 1055, 1065, 5, 14, 0, 0, 1056, 1066, 5, 11, 0, 0, 1057,
		1062, 3, 164, 82, 0, 1058, 1059, 5, 15, 0, 0, 1059, 1061, 3, 164, 82, 0,
		1060, 1058, 1, 0, 0, 0, 1061, 1064, 1, 0, 0, 0, 1062, 1060, 1, 0, 0, 0,
		1062, 1063, 1, 0, 0, 0, 1063, 1066, 1, 0, 0, 0, 1064, 1062, 1, 0, 0, 0,
		1065, 1056, 1, 0, 0, 0, 1065, 1057, 1, 0, 0, 0, 1066, 1067, 1, 0, 0, 0,
		1067, 1068, 5, 16, 0, 0, 1068, 163, 1, 0, 0, 0, 1069, 1070, 3, 186, 93,
		0, 1070, 1071, 5, 11, 0, 0, 1071, 1072, 3, 116, 58, 0, 1072, 165, 1, 0,
		0, 0, 1073, 1078, 5, 21, 0, 0, 1074, 1075, 5, 22, 0, 0, 1075, 1076, 3,
		38, 19, 0, 1076, 1077, 5, 23, 0, 0, 1077, 1079, 1, 0, 0, 0, 1078, 1074,
		1, 0, 0, 0, 1078, 1079, 1, 0, 0, 0, 1079, 1081, 1, 0, 0, 0, 1080, 1073,
		1, 0, 0, 0, 1080, 1081, 1, 0, 0, 0, 1081, 1082, 1, 0, 0, 0, 1082, 1091,
		5, 14, 0, 0, 1083, 1088, 3, 116, 58, 0, 1084, 1085, 5, 15, 0, 0, 1085,
		1087, 3, 116, 58, 0, 1086, 1084, 1, 0, 0, 0, 1087, 1090, 1, 0, 0, 0, 1088,
		1086, 1, 0, 0, 0, 1088, 1089, 1, 0, 0, 0, 1089, 1092, 1, 0, 0, 0, 1090,
		1088, 1, 0, 0, 0, 1091, 1083, 1, 0, 0, 0, 1091, 1092, 1, 0, 0, 0, 1092,
		1093, 1, 0, 0, 0, 1093, 1094, 5, 16, 0, 0, 1094, 167, 1, 0, 0, 0, 1095,
		1096, 5, 150, 0, 0, 1096, 1097, 5, 159, 0, 0, 1097, 169, 1, 0, 0, 0, 1098,
		1099, 5, 151, 0, 0, 1099, 1100, 5, 159, 0, 0, 1100, 1101, 5, 19, 0, 0,
		1101, 1103, 3, 20, 10, 0, 1102, 1104, 3, 168, 84, 0, 1103, 1102, 1, 0,
		0, 0, 1103, 1104, 1, 0, 0, 0, 1104, 171, 1, 0, 0, 0, 1105, 1106, 5, 152,
		0, 0, 1106, 1107, 5, 14, 0, 0, 1107, 1112, 3, 170, 85, 0, 1108, 1109, 5,
		15, 0, 0, 1109, 1111, 3, 170, 85, 0, 1110, 1108, 1, 0, 0, 0, 1111, 1114,
		1, 0, 0, 0, 1112, 1110, 1, 0, 0, 0, 1112, 1113, 1, 0, 0, 0, 1113, 1115,
		1, 0, 0, 0, 1114, 1112, 1, 0, 0, 0, 1115, 1117, 5, 16, 0, 0, 1116, 1118,
		3, 168, 84, 0, 1117, 1116, 1, 0, 0, 0, 1117, 1118, 1, 0, 0, 0, 1118, 173,
		1, 0, 0, 0, 1119, 1120, 7, 29, 0, 0, 1120, 175, 1, 0, 0, 0, 1121, 1122,
		7, 30, 0, 0, 1122, 177, 1, 0, 0, 0, 1123, 1124, 7, 31, 0, 0, 1124, 179,
		1, 0, 0, 0, 1125, 1126, 7, 32, 0, 0, 1126, 181, 1, 0, 0, 0, 1127, 1128,
		7, 33, 0, 0, 1128, 183, 1, 0, 0, 0, 1129, 1130, 7, 34, 0, 0, 1130, 185,
		1, 0, 0, 0, 1131, 1134, 3, 192, 96, 0, 1132, 1134, 3, 178, 89, 0, 1133,
		1131, 1, 0, 0, 0, 1133, 1132, 1, 0, 0, 0, 1134, 187, 1, 0, 0, 0, 1135,
		1138, 3, 186, 93, 0, 1136, 1138, 3, 184, 92, 0, 1137, 1135, 1, 0, 0, 0,
		1137, 1136, 1, 0, 0, 0, 1138, 189, 1, 0, 0, 0, 1139, 1142, 3, 192, 96,
		0, 1140, 1142, 3, 182, 91, 0, 1141, 1139, 1, 0, 0, 0, 1141, 1140, 1, 0,
		0, 0, 1142, 191, 1, 0, 0, 0, 1143, 1144, 7, 35, 0, 0, 1144, 193, 1, 0,
		0, 0, 1145, 1148, 5, 153, 0, 0, 1146, 1149, 3, 192, 96, 0, 1147, 1149,
		5, 159, 0, 0, 1148, 1146, 1, 0, 0, 0, 1148, 1147, 1, 0, 0, 0, 1149, 195,
		1, 0, 0, 0, 1150, 1155, 3, 116, 58, 0, 1151, 1152, 5, 15, 0, 0, 1152, 1154,
		3, 116, 58, 0, 1153, 1151, 1, 0, 0, 0, 1154, 1157, 1, 0, 0, 0, 1155, 1153,
		1, 0, 0, 0, 1155, 1156, 1, 0, 0, 0, 1156, 197, 1, 0, 0, 0, 1157, 1155,
		1, 0, 0, 0, 1158, 1160, 5, 160, 0, 0, 1159, 1161, 3, 200, 100, 0, 1160,
		1159, 1, 0, 0, 0, 1160, 1161, 1, 0, 0, 0, 1161, 199, 1, 0, 0, 0, 1162,
		1166, 3, 118, 59, 0, 1163, 1166, 3, 122, 61, 0, 1164, 1166, 5, 159, 0,
		0, 1165, 1162, 1, 0, 0, 0, 1165, 1163, 1, 0, 0, 0, 1165, 1164, 1, 0, 0,
		0, 1166, 201, 1, 0, 0, 0, 133, 203, 208, 214, 220, 226, 232, 238, 244,
		250, 259, 265, 271, 275, 282, 287, 291, 294, 302, 305, 313, 316, 325, 333,
		340, 349, 352, 363, 368, 373, 390, 397, 421, 436, 444, 448, 458, 464, 474,
		477, 482, 487, 500, 509, 525, 532, 535, 545, 551, 556, 560, 563, 566, 569,
		576, 585, 597, 609, 612, 618, 625, 635, 653, 655, 675, 691, 706, 724, 732,
		739, 741, 750, 761, 810, 815, 828, 830, 832, 851, 853, 872, 877, 880, 885,
		887, 890, 894, 898, 901, 904, 908, 911, 914, 917, 921, 924, 927, 931, 934,
		937, 940, 946, 950, 953, 957, 960, 964, 968, 970, 985, 989, 994, 1003,
		1008, 1024, 1034, 1043, 1046, 1062, 1065, 1078, 1080, 1088, 1091, 1103,
		1112, 1117, 1133, 1137, 1141, 1148, 1155, 1160, 1165,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// cqlParserInit initializes any static state used to implement cqlParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewcqlParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func CqlParserInit() {
	staticData := &cqlParserStaticData
	staticData.once.Do(cqlParserInit)
}

// NewcqlParser produces a new parser instance for the optional input antlr.TokenStream.
func NewcqlParser(input antlr.TokenStream) *cqlParser {
	CqlParserInit()
	this := new(cqlParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &cqlParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "cql.g4"

	return this
}

// cqlParser tokens.
const (
	cqlParserEOF                 = antlr.TokenEOF
	cqlParserT__0                = 1
	cqlParserT__1                = 2
	cqlParserT__2                = 3
	cqlParserT__3                = 4
	cqlParserT__4                = 5
	cqlParserT__5                = 6
	cqlParserT__6                = 7
	cqlParserT__7                = 8
	cqlParserT__8                = 9
	cqlParserT__9                = 10
	cqlParserT__10               = 11
	cqlParserT__11               = 12
	cqlParserT__12               = 13
	cqlParserT__13               = 14
	cqlParserT__14               = 15
	cqlParserT__15               = 16
	cqlParserT__16               = 17
	cqlParserT__17               = 18
	cqlParserT__18               = 19
	cqlParserT__19               = 20
	cqlParserT__20               = 21
	cqlParserT__21               = 22
	cqlParserT__22               = 23
	cqlParserT__23               = 24
	cqlParserT__24               = 25
	cqlParserT__25               = 26
	cqlParserT__26               = 27
	cqlParserT__27               = 28
	cqlParserT__28               = 29
	cqlParserT__29               = 30
	cqlParserT__30               = 31
	cqlParserT__31               = 32
	cqlParserT__32               = 33
	cqlParserT__33               = 34
	cqlParserT__34               = 35
	cqlParserT__35               = 36
	cqlParserT__36               = 37
	cqlParserT__37               = 38
	cqlParserT__38               = 39
	cqlParserT__39               = 40
	cqlParserT__40               = 41
	cqlParserT__41               = 42
	cqlParserT__42               = 43
	cqlParserT__43               = 44
	cqlParserT__44               = 45
	cqlParserT__45               = 46
	cqlParserT__46               = 47
	cqlParserT__47               = 48
	cqlParserT__48               = 49
	cqlParserT__49               = 50
	cqlParserT__50               = 51
	cqlParserT__51               = 52
	cqlParserT__52               = 53
	cqlParserT__53               = 54
	cqlParserT__54               = 55
	cqlParserT__55               = 56
	cqlParserT__56               = 57
	cqlParserT__57               = 58
	cqlParserT__58               = 59
	cqlParserT__59               = 60
	cqlParserT__60               = 61
	cqlParserT__61               = 62
	cqlParserT__62               = 63
	cqlParserT__63               = 64
	cqlParserT__64               = 65
	cqlParserT__65               = 66
	cqlParserT__66               = 67
	cqlParserT__67               = 68
	cqlParserT__68               = 69
	cqlParserT__69               = 70
	cqlParserT__70               = 71
	cqlParserT__71               = 72
	cqlParserT__72               = 73
	cqlParserT__73               = 74
	cqlParserT__74               = 75
	cqlParserT__75               = 76
	cqlParserT__76               = 77
	cqlParserT__77               = 78
	cqlParserT__78               = 79
	cqlParserT__79               = 80
	cqlParserT__80               = 81
	cqlParserT__81               = 82
	cqlParserT__82               = 83
	cqlParserT__83               = 84
	cqlParserT__84               = 85
	cqlParserT__85               = 86
	cqlParserT__86               = 87
	cqlParserT__87               = 88
	cqlParserT__88               = 89
	cqlParserT__89               = 90
	cqlParserT__90               = 91
	cqlParserT__91               = 92
	cqlParserT__92               = 93
	cqlParserT__93               = 94
	cqlParserT__94               = 95
	cqlParserT__95               = 96
	cqlParserT__96               = 97
	cqlParserT__97               = 98
	cqlParserT__98               = 99
	cqlParserT__99               = 100
	cqlParserT__100              = 101
	cqlParserT__101              = 102
	cqlParserT__102              = 103
	cqlParserT__103              = 104
	cqlParserT__104              = 105
	cqlParserT__105              = 106
	cqlParserT__106              = 107
	cqlParserT__107              = 108
	cqlParserT__108              = 109
	cqlParserT__109              = 110
	cqlParserT__110              = 111
	cqlParserT__111              = 112
	cqlParserT__112              = 113
	cqlParserT__113              = 114
	cqlParserT__114              = 115
	cqlParserT__115              = 116
	cqlParserT__116              = 117
	cqlParserT__117              = 118
	cqlParserT__118              = 119
	cqlParserT__119              = 120
	cqlParserT__120              = 121
	cqlParserT__121              = 122
	cqlParserT__122              = 123
	cqlParserT__123              = 124
	cqlParserT__124              = 125
	cqlParserT__125              = 126
	cqlParserT__126              = 127
	cqlParserT__127              = 128
	cqlParserT__128              = 129
	cqlParserT__129              = 130
	cqlParserT__130              = 131
	cqlParserT__131              = 132
	cqlParserT__132              = 133
	cqlParserT__133              = 134
	cqlParserT__134              = 135
	cqlParserT__135              = 136
	cqlParserT__136              = 137
	cqlParserT__137              = 138
	cqlParserT__138              = 139
	cqlParserT__139              = 140
	cqlParserT__140              = 141
	cqlParserT__141              = 142
	cqlParserT__142              = 143
	cqlParserT__143              = 144
	cqlParserT__144              = 145
	cqlParserT__145              = 146
	cqlParserT__146              = 147
	cqlParserT__147              = 148
	cqlParserT__148              = 149
	cqlParserT__149              = 150
	cqlParserT__150              = 151
	cqlParserT__151              = 152
	cqlParserT__152              = 153
	cqlParserQUOTEDIDENTIFIER    = 154
	cqlParserDATETIME            = 155
	cqlParserTIME                = 156
	cqlParserIDENTIFIER          = 157
	cqlParserDELIMITEDIDENTIFIER = 158
	cqlParserSTRING              = 159
	cqlParserNUMBER              = 160
	cqlParserWS                  = 161
	cqlParserCOMMENT             = 162
	cqlParserLINE_COMMENT        = 163
)

// cqlParser rules.
const (
	cqlParserRULE_library                         = 0
	cqlParserRULE_libraryDefinition               = 1
	cqlParserRULE_usingDefinition                 = 2
	cqlParserRULE_includeDefinition               = 3
	cqlParserRULE_localIdentifier                 = 4
	cqlParserRULE_accessModifier                  = 5
	cqlParserRULE_parameterDefinition             = 6
	cqlParserRULE_codesystemDefinition            = 7
	cqlParserRULE_valuesetDefinition              = 8
	cqlParserRULE_codesystems                     = 9
	cqlParserRULE_codesystemIdentifier            = 10
	cqlParserRULE_libraryIdentifier               = 11
	cqlParserRULE_codeDefinition                  = 12
	cqlParserRULE_conceptDefinition               = 13
	cqlParserRULE_codeIdentifier                  = 14
	cqlParserRULE_codesystemId                    = 15
	cqlParserRULE_valuesetId                      = 16
	cqlParserRULE_versionSpecifier                = 17
	cqlParserRULE_codeId                          = 18
	cqlParserRULE_typeSpecifier                   = 19
	cqlParserRULE_namedTypeSpecifier              = 20
	cqlParserRULE_modelIdentifier                 = 21
	cqlParserRULE_listTypeSpecifier               = 22
	cqlParserRULE_intervalTypeSpecifier           = 23
	cqlParserRULE_tupleTypeSpecifier              = 24
	cqlParserRULE_tupleElementDefinition          = 25
	cqlParserRULE_choiceTypeSpecifier             = 26
	cqlParserRULE_statement                       = 27
	cqlParserRULE_expressionDefinition            = 28
	cqlParserRULE_contextDefinition               = 29
	cqlParserRULE_functionDefinition              = 30
	cqlParserRULE_operandDefinition               = 31
	cqlParserRULE_functionBody                    = 32
	cqlParserRULE_querySource                     = 33
	cqlParserRULE_aliasedQuerySource              = 34
	cqlParserRULE_alias                           = 35
	cqlParserRULE_queryInclusionClause            = 36
	cqlParserRULE_withClause                      = 37
	cqlParserRULE_withoutClause                   = 38
	cqlParserRULE_retrieve                        = 39
	cqlParserRULE_contextIdentifier               = 40
	cqlParserRULE_codePath                        = 41
	cqlParserRULE_terminology                     = 42
	cqlParserRULE_qualifier                       = 43
	cqlParserRULE_query                           = 44
	cqlParserRULE_sourceClause                    = 45
	cqlParserRULE_letClause                       = 46
	cqlParserRULE_letClauseItem                   = 47
	cqlParserRULE_whereClause                     = 48
	cqlParserRULE_returnClause                    = 49
	cqlParserRULE_sortClause                      = 50
	cqlParserRULE_sortDirection                   = 51
	cqlParserRULE_sortByItem                      = 52
	cqlParserRULE_qualifiedIdentifier             = 53
	cqlParserRULE_qualifiedIdentifierExpression   = 54
	cqlParserRULE_qualifierExpression             = 55
	cqlParserRULE_simplePath                      = 56
	cqlParserRULE_simpleLiteral                   = 57
	cqlParserRULE_expression                      = 58
	cqlParserRULE_dateTimePrecision               = 59
	cqlParserRULE_dateTimeComponent               = 60
	cqlParserRULE_pluralDateTimePrecision         = 61
	cqlParserRULE_expressionTerm                  = 62
	cqlParserRULE_caseExpressionItem              = 63
	cqlParserRULE_dateTimePrecisionSpecifier      = 64
	cqlParserRULE_relativeQualifier               = 65
	cqlParserRULE_offsetRelativeQualifier         = 66
	cqlParserRULE_exclusiveRelativeQualifier      = 67
	cqlParserRULE_quantityOffset                  = 68
	cqlParserRULE_temporalRelationship            = 69
	cqlParserRULE_intervalOperatorPhrase          = 70
	cqlParserRULE_term                            = 71
	cqlParserRULE_qualifiedInvocation             = 72
	cqlParserRULE_qualifiedFunction               = 73
	cqlParserRULE_invocation                      = 74
	cqlParserRULE_function                        = 75
	cqlParserRULE_ratio                           = 76
	cqlParserRULE_literal                         = 77
	cqlParserRULE_intervalSelector                = 78
	cqlParserRULE_tupleSelector                   = 79
	cqlParserRULE_tupleElementSelector            = 80
	cqlParserRULE_instanceSelector                = 81
	cqlParserRULE_instanceElementSelector         = 82
	cqlParserRULE_listSelector                    = 83
	cqlParserRULE_displayClause                   = 84
	cqlParserRULE_codeSelector                    = 85
	cqlParserRULE_conceptSelector                 = 86
	cqlParserRULE_keyword                         = 87
	cqlParserRULE_reservedWord                    = 88
	cqlParserRULE_keywordIdentifier               = 89
	cqlParserRULE_obsoleteIdentifier              = 90
	cqlParserRULE_functionIdentifier              = 91
	cqlParserRULE_typeNameIdentifier              = 92
	cqlParserRULE_referentialIdentifier           = 93
	cqlParserRULE_referentialOrTypeNameIdentifier = 94
	cqlParserRULE_identifierOrFunctionIdentifier  = 95
	cqlParserRULE_identifier                      = 96
	cqlParserRULE_externalConstant                = 97
	cqlParserRULE_paramList                       = 98
	cqlParserRULE_quantity                        = 99
	cqlParserRULE_unit                            = 100
)

// ILibraryContext is an interface to support dynamic dispatch.
type ILibraryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	LibraryDefinition() ILibraryDefinitionContext
	AllUsingDefinition() []IUsingDefinitionContext
	UsingDefinition(i int) IUsingDefinitionContext
	AllIncludeDefinition() []IIncludeDefinitionContext
	IncludeDefinition(i int) IIncludeDefinitionContext
	AllCodesystemDefinition() []ICodesystemDefinitionContext
	CodesystemDefinition(i int) ICodesystemDefinitionContext
	AllValuesetDefinition() []IValuesetDefinitionContext
	ValuesetDefinition(i int) IValuesetDefinitionContext
	AllCodeDefinition() []ICodeDefinitionContext
	CodeDefinition(i int) ICodeDefinitionContext
	AllConceptDefinition() []IConceptDefinitionContext
	ConceptDefinition(i int) IConceptDefinitionContext
	AllParameterDefinition() []IParameterDefinitionContext
	ParameterDefinition(i int) IParameterDefinitionContext
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsLibraryContext differentiates from other interfaces.
	IsLibraryContext()
}

type LibraryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryContext() *LibraryContext {
	var p = new(LibraryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_library
	return p
}

func (*LibraryContext) IsLibraryContext() {}

func NewLibraryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryContext {
	var p = new(LibraryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_library

	return p
}

func (s *LibraryContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryContext) EOF() antlr.TerminalNode {
	return s.GetToken(cqlParserEOF, 0)
}

func (s *LibraryContext) LibraryDefinition() ILibraryDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryDefinitionContext)
}

func (s *LibraryContext) AllUsingDefinition() []IUsingDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUsingDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IUsingDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUsingDefinitionContext); ok {
			tst[i] = t.(IUsingDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *LibraryContext) UsingDefinition(i int) IUsingDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingDefinitionContext)
}

func (s *LibraryContext) AllIncludeDefinition() []IIncludeDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIncludeDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IIncludeDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIncludeDefinitionContext); ok {
			tst[i] = t.(IIncludeDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *LibraryContext) IncludeDefinition(i int) IIncludeDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIncludeDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIncludeDefinitionContext)
}

func (s *LibraryContext) AllCodesystemDefinition() []ICodesystemDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICodesystemDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ICodesystemDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICodesystemDefinitionContext); ok {
			tst[i] = t.(ICodesystemDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *LibraryContext) CodesystemDefinition(i int) ICodesystemDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodesystemDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodesystemDefinitionContext)
}

func (s *LibraryContext) AllValuesetDefinition() []IValuesetDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValuesetDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IValuesetDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValuesetDefinitionContext); ok {
			tst[i] = t.(IValuesetDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *LibraryContext) ValuesetDefinition(i int) IValuesetDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesetDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesetDefinitionContext)
}

func (s *LibraryContext) AllCodeDefinition() []ICodeDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICodeDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ICodeDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICodeDefinitionContext); ok {
			tst[i] = t.(ICodeDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *LibraryContext) CodeDefinition(i int) ICodeDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeDefinitionContext)
}

func (s *LibraryContext) AllConceptDefinition() []IConceptDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConceptDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IConceptDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConceptDefinitionContext); ok {
			tst[i] = t.(IConceptDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *LibraryContext) ConceptDefinition(i int) IConceptDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConceptDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConceptDefinitionContext)
}

func (s *LibraryContext) AllParameterDefinition() []IParameterDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IParameterDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterDefinitionContext); ok {
			tst[i] = t.(IParameterDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *LibraryContext) ParameterDefinition(i int) IParameterDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterDefinitionContext)
}

func (s *LibraryContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *LibraryContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *LibraryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterLibrary(s)
	}
}

func (s *LibraryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitLibrary(s)
	}
}

func (p *cqlParser) Library() (localctx ILibraryContext) {
	this := p
	_ = this

	localctx = NewLibraryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, cqlParserRULE_library)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(203)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cqlParserT__0 {
		{
			p.SetState(202)
			p.LibraryDefinition()
		}

	}
	p.SetState(208)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cqlParserT__2 {
		{
			p.SetState(205)
			p.UsingDefinition()
		}

		p.SetState(210)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(214)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cqlParserT__3 {
		{
			p.SetState(211)
			p.IncludeDefinition()
		}

		p.SetState(216)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(220)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(217)
				p.CodesystemDefinition()
			}

		}
		p.SetState(222)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())
	}
	p.SetState(226)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(223)
				p.ValuesetDefinition()
			}

		}
		p.SetState(228)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext())
	}
	p.SetState(232)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(229)
				p.CodeDefinition()
			}

		}
		p.SetState(234)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())
	}
	p.SetState(238)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(235)
				p.ConceptDefinition()
			}

		}
		p.SetState(240)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())
	}
	p.SetState(244)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&448) != 0 {
		{
			p.SetState(241)
			p.ParameterDefinition()
		}

		p.SetState(246)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(250)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cqlParserT__26 || _la == cqlParserT__27 {
		{
			p.SetState(247)
			p.Statement()
		}

		p.SetState(252)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(253)
		p.Match(cqlParserEOF)
	}

	return localctx
}

// ILibraryDefinitionContext is an interface to support dynamic dispatch.
type ILibraryDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext
	VersionSpecifier() IVersionSpecifierContext

	// IsLibraryDefinitionContext differentiates from other interfaces.
	IsLibraryDefinitionContext()
}

type LibraryDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryDefinitionContext() *LibraryDefinitionContext {
	var p = new(LibraryDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_libraryDefinition
	return p
}

func (*LibraryDefinitionContext) IsLibraryDefinitionContext() {}

func NewLibraryDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryDefinitionContext {
	var p = new(LibraryDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_libraryDefinition

	return p
}

func (s *LibraryDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryDefinitionContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *LibraryDefinitionContext) VersionSpecifier() IVersionSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionSpecifierContext)
}

func (s *LibraryDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterLibraryDefinition(s)
	}
}

func (s *LibraryDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitLibraryDefinition(s)
	}
}

func (p *cqlParser) LibraryDefinition() (localctx ILibraryDefinitionContext) {
	this := p
	_ = this

	localctx = NewLibraryDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, cqlParserRULE_libraryDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(255)
		p.Match(cqlParserT__0)
	}
	{
		p.SetState(256)
		p.QualifiedIdentifier()
	}
	p.SetState(259)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cqlParserT__1 {
		{
			p.SetState(257)
			p.Match(cqlParserT__1)
		}
		{
			p.SetState(258)
			p.VersionSpecifier()
		}

	}

	return localctx
}

// IUsingDefinitionContext is an interface to support dynamic dispatch.
type IUsingDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ModelIdentifier() IModelIdentifierContext
	VersionSpecifier() IVersionSpecifierContext

	// IsUsingDefinitionContext differentiates from other interfaces.
	IsUsingDefinitionContext()
}

type UsingDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsingDefinitionContext() *UsingDefinitionContext {
	var p = new(UsingDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_usingDefinition
	return p
}

func (*UsingDefinitionContext) IsUsingDefinitionContext() {}

func NewUsingDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsingDefinitionContext {
	var p = new(UsingDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_usingDefinition

	return p
}

func (s *UsingDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *UsingDefinitionContext) ModelIdentifier() IModelIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModelIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModelIdentifierContext)
}

func (s *UsingDefinitionContext) VersionSpecifier() IVersionSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionSpecifierContext)
}

func (s *UsingDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsingDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsingDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterUsingDefinition(s)
	}
}

func (s *UsingDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitUsingDefinition(s)
	}
}

func (p *cqlParser) UsingDefinition() (localctx IUsingDefinitionContext) {
	this := p
	_ = this

	localctx = NewUsingDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, cqlParserRULE_usingDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(261)
		p.Match(cqlParserT__2)
	}
	{
		p.SetState(262)
		p.ModelIdentifier()
	}
	p.SetState(265)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cqlParserT__1 {
		{
			p.SetState(263)
			p.Match(cqlParserT__1)
		}
		{
			p.SetState(264)
			p.VersionSpecifier()
		}

	}

	return localctx
}

// IIncludeDefinitionContext is an interface to support dynamic dispatch.
type IIncludeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext
	VersionSpecifier() IVersionSpecifierContext
	LocalIdentifier() ILocalIdentifierContext

	// IsIncludeDefinitionContext differentiates from other interfaces.
	IsIncludeDefinitionContext()
}

type IncludeDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIncludeDefinitionContext() *IncludeDefinitionContext {
	var p = new(IncludeDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_includeDefinition
	return p
}

func (*IncludeDefinitionContext) IsIncludeDefinitionContext() {}

func NewIncludeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IncludeDefinitionContext {
	var p = new(IncludeDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_includeDefinition

	return p
}

func (s *IncludeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *IncludeDefinitionContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *IncludeDefinitionContext) VersionSpecifier() IVersionSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionSpecifierContext)
}

func (s *IncludeDefinitionContext) LocalIdentifier() ILocalIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalIdentifierContext)
}

func (s *IncludeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IncludeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IncludeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterIncludeDefinition(s)
	}
}

func (s *IncludeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitIncludeDefinition(s)
	}
}

func (p *cqlParser) IncludeDefinition() (localctx IIncludeDefinitionContext) {
	this := p
	_ = this

	localctx = NewIncludeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, cqlParserRULE_includeDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(267)
		p.Match(cqlParserT__3)
	}
	{
		p.SetState(268)
		p.QualifiedIdentifier()
	}
	p.SetState(271)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cqlParserT__1 {
		{
			p.SetState(269)
			p.Match(cqlParserT__1)
		}
		{
			p.SetState(270)
			p.VersionSpecifier()
		}

	}
	p.SetState(275)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cqlParserT__4 {
		{
			p.SetState(273)
			p.Match(cqlParserT__4)
		}
		{
			p.SetState(274)
			p.LocalIdentifier()
		}

	}

	return localctx
}

// ILocalIdentifierContext is an interface to support dynamic dispatch.
type ILocalIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsLocalIdentifierContext differentiates from other interfaces.
	IsLocalIdentifierContext()
}

type LocalIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalIdentifierContext() *LocalIdentifierContext {
	var p = new(LocalIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_localIdentifier
	return p
}

func (*LocalIdentifierContext) IsLocalIdentifierContext() {}

func NewLocalIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalIdentifierContext {
	var p = new(LocalIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_localIdentifier

	return p
}

func (s *LocalIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LocalIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterLocalIdentifier(s)
	}
}

func (s *LocalIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitLocalIdentifier(s)
	}
}

func (p *cqlParser) LocalIdentifier() (localctx ILocalIdentifierContext) {
	this := p
	_ = this

	localctx = NewLocalIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, cqlParserRULE_localIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(277)
		p.Identifier()
	}

	return localctx
}

// IAccessModifierContext is an interface to support dynamic dispatch.
type IAccessModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAccessModifierContext differentiates from other interfaces.
	IsAccessModifierContext()
}

type AccessModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccessModifierContext() *AccessModifierContext {
	var p = new(AccessModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_accessModifier
	return p
}

func (*AccessModifierContext) IsAccessModifierContext() {}

func NewAccessModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccessModifierContext {
	var p = new(AccessModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_accessModifier

	return p
}

func (s *AccessModifierContext) GetParser() antlr.Parser { return s.parser }
func (s *AccessModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccessModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AccessModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterAccessModifier(s)
	}
}

func (s *AccessModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitAccessModifier(s)
	}
}

func (p *cqlParser) AccessModifier() (localctx IAccessModifierContext) {
	this := p
	_ = this

	localctx = NewAccessModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, cqlParserRULE_accessModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(279)
		_la = p.GetTokenStream().LA(1)

		if !(_la == cqlParserT__5 || _la == cqlParserT__6) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IParameterDefinitionContext is an interface to support dynamic dispatch.
type IParameterDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AccessModifier() IAccessModifierContext
	TypeSpecifier() ITypeSpecifierContext
	Expression() IExpressionContext

	// IsParameterDefinitionContext differentiates from other interfaces.
	IsParameterDefinitionContext()
}

type ParameterDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterDefinitionContext() *ParameterDefinitionContext {
	var p = new(ParameterDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_parameterDefinition
	return p
}

func (*ParameterDefinitionContext) IsParameterDefinitionContext() {}

func NewParameterDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterDefinitionContext {
	var p = new(ParameterDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_parameterDefinition

	return p
}

func (s *ParameterDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ParameterDefinitionContext) AccessModifier() IAccessModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *ParameterDefinitionContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *ParameterDefinitionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParameterDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterParameterDefinition(s)
	}
}

func (s *ParameterDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitParameterDefinition(s)
	}
}

func (p *cqlParser) ParameterDefinition() (localctx IParameterDefinitionContext) {
	this := p
	_ = this

	localctx = NewParameterDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, cqlParserRULE_parameterDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(282)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cqlParserT__5 || _la == cqlParserT__6 {
		{
			p.SetState(281)
			p.AccessModifier()
		}

	}
	{
		p.SetState(284)
		p.Match(cqlParserT__7)
	}
	{
		p.SetState(285)
		p.Identifier()
	}
	p.SetState(287)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(286)
			p.TypeSpecifier()
		}

	}
	p.SetState(291)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cqlParserT__8 {
		{
			p.SetState(289)
			p.Match(cqlParserT__8)
		}
		{
			p.SetState(290)
			p.expression(0)
		}

	}

	return localctx
}

// ICodesystemDefinitionContext is an interface to support dynamic dispatch.
type ICodesystemDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	CodesystemId() ICodesystemIdContext
	AccessModifier() IAccessModifierContext
	VersionSpecifier() IVersionSpecifierContext

	// IsCodesystemDefinitionContext differentiates from other interfaces.
	IsCodesystemDefinitionContext()
}

type CodesystemDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodesystemDefinitionContext() *CodesystemDefinitionContext {
	var p = new(CodesystemDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_codesystemDefinition
	return p
}

func (*CodesystemDefinitionContext) IsCodesystemDefinitionContext() {}

func NewCodesystemDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodesystemDefinitionContext {
	var p = new(CodesystemDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_codesystemDefinition

	return p
}

func (s *CodesystemDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *CodesystemDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CodesystemDefinitionContext) CodesystemId() ICodesystemIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodesystemIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodesystemIdContext)
}

func (s *CodesystemDefinitionContext) AccessModifier() IAccessModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *CodesystemDefinitionContext) VersionSpecifier() IVersionSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionSpecifierContext)
}

func (s *CodesystemDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodesystemDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodesystemDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterCodesystemDefinition(s)
	}
}

func (s *CodesystemDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitCodesystemDefinition(s)
	}
}

func (p *cqlParser) CodesystemDefinition() (localctx ICodesystemDefinitionContext) {
	this := p
	_ = this

	localctx = NewCodesystemDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, cqlParserRULE_codesystemDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(294)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cqlParserT__5 || _la == cqlParserT__6 {
		{
			p.SetState(293)
			p.AccessModifier()
		}

	}
	{
		p.SetState(296)
		p.Match(cqlParserT__9)
	}
	{
		p.SetState(297)
		p.Identifier()
	}
	{
		p.SetState(298)
		p.Match(cqlParserT__10)
	}
	{
		p.SetState(299)
		p.CodesystemId()
	}
	p.SetState(302)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cqlParserT__1 {
		{
			p.SetState(300)
			p.Match(cqlParserT__1)
		}
		{
			p.SetState(301)
			p.VersionSpecifier()
		}

	}

	return localctx
}

// IValuesetDefinitionContext is an interface to support dynamic dispatch.
type IValuesetDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ValuesetId() IValuesetIdContext
	AccessModifier() IAccessModifierContext
	VersionSpecifier() IVersionSpecifierContext
	Codesystems() ICodesystemsContext

	// IsValuesetDefinitionContext differentiates from other interfaces.
	IsValuesetDefinitionContext()
}

type ValuesetDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuesetDefinitionContext() *ValuesetDefinitionContext {
	var p = new(ValuesetDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_valuesetDefinition
	return p
}

func (*ValuesetDefinitionContext) IsValuesetDefinitionContext() {}

func NewValuesetDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuesetDefinitionContext {
	var p = new(ValuesetDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_valuesetDefinition

	return p
}

func (s *ValuesetDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuesetDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ValuesetDefinitionContext) ValuesetId() IValuesetIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesetIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesetIdContext)
}

func (s *ValuesetDefinitionContext) AccessModifier() IAccessModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *ValuesetDefinitionContext) VersionSpecifier() IVersionSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionSpecifierContext)
}

func (s *ValuesetDefinitionContext) Codesystems() ICodesystemsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodesystemsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodesystemsContext)
}

func (s *ValuesetDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesetDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValuesetDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterValuesetDefinition(s)
	}
}

func (s *ValuesetDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitValuesetDefinition(s)
	}
}

func (p *cqlParser) ValuesetDefinition() (localctx IValuesetDefinitionContext) {
	this := p
	_ = this

	localctx = NewValuesetDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, cqlParserRULE_valuesetDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(305)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cqlParserT__5 || _la == cqlParserT__6 {
		{
			p.SetState(304)
			p.AccessModifier()
		}

	}
	{
		p.SetState(307)
		p.Match(cqlParserT__11)
	}
	{
		p.SetState(308)
		p.Identifier()
	}
	{
		p.SetState(309)
		p.Match(cqlParserT__10)
	}
	{
		p.SetState(310)
		p.ValuesetId()
	}
	p.SetState(313)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cqlParserT__1 {
		{
			p.SetState(311)
			p.Match(cqlParserT__1)
		}
		{
			p.SetState(312)
			p.VersionSpecifier()
		}

	}
	p.SetState(316)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cqlParserT__12 {
		{
			p.SetState(315)
			p.Codesystems()
		}

	}

	return localctx
}

// ICodesystemsContext is an interface to support dynamic dispatch.
type ICodesystemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCodesystemIdentifier() []ICodesystemIdentifierContext
	CodesystemIdentifier(i int) ICodesystemIdentifierContext

	// IsCodesystemsContext differentiates from other interfaces.
	IsCodesystemsContext()
}

type CodesystemsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodesystemsContext() *CodesystemsContext {
	var p = new(CodesystemsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_codesystems
	return p
}

func (*CodesystemsContext) IsCodesystemsContext() {}

func NewCodesystemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodesystemsContext {
	var p = new(CodesystemsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_codesystems

	return p
}

func (s *CodesystemsContext) GetParser() antlr.Parser { return s.parser }

func (s *CodesystemsContext) AllCodesystemIdentifier() []ICodesystemIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICodesystemIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ICodesystemIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICodesystemIdentifierContext); ok {
			tst[i] = t.(ICodesystemIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CodesystemsContext) CodesystemIdentifier(i int) ICodesystemIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodesystemIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodesystemIdentifierContext)
}

func (s *CodesystemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodesystemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodesystemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterCodesystems(s)
	}
}

func (s *CodesystemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitCodesystems(s)
	}
}

func (p *cqlParser) Codesystems() (localctx ICodesystemsContext) {
	this := p
	_ = this

	localctx = NewCodesystemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, cqlParserRULE_codesystems)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(318)
		p.Match(cqlParserT__12)
	}
	{
		p.SetState(319)
		p.Match(cqlParserT__13)
	}
	{
		p.SetState(320)
		p.CodesystemIdentifier()
	}
	p.SetState(325)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cqlParserT__14 {
		{
			p.SetState(321)
			p.Match(cqlParserT__14)
		}
		{
			p.SetState(322)
			p.CodesystemIdentifier()
		}

		p.SetState(327)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(328)
		p.Match(cqlParserT__15)
	}

	return localctx
}

// ICodesystemIdentifierContext is an interface to support dynamic dispatch.
type ICodesystemIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LibraryIdentifier() ILibraryIdentifierContext

	// IsCodesystemIdentifierContext differentiates from other interfaces.
	IsCodesystemIdentifierContext()
}

type CodesystemIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodesystemIdentifierContext() *CodesystemIdentifierContext {
	var p = new(CodesystemIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_codesystemIdentifier
	return p
}

func (*CodesystemIdentifierContext) IsCodesystemIdentifierContext() {}

func NewCodesystemIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodesystemIdentifierContext {
	var p = new(CodesystemIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_codesystemIdentifier

	return p
}

func (s *CodesystemIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *CodesystemIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CodesystemIdentifierContext) LibraryIdentifier() ILibraryIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryIdentifierContext)
}

func (s *CodesystemIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodesystemIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodesystemIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterCodesystemIdentifier(s)
	}
}

func (s *CodesystemIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitCodesystemIdentifier(s)
	}
}

func (p *cqlParser) CodesystemIdentifier() (localctx ICodesystemIdentifierContext) {
	this := p
	_ = this

	localctx = NewCodesystemIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, cqlParserRULE_codesystemIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(333)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(330)
			p.LibraryIdentifier()
		}
		{
			p.SetState(331)
			p.Match(cqlParserT__16)
		}

	}
	{
		p.SetState(335)
		p.Identifier()
	}

	return localctx
}

// ILibraryIdentifierContext is an interface to support dynamic dispatch.
type ILibraryIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsLibraryIdentifierContext differentiates from other interfaces.
	IsLibraryIdentifierContext()
}

type LibraryIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryIdentifierContext() *LibraryIdentifierContext {
	var p = new(LibraryIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_libraryIdentifier
	return p
}

func (*LibraryIdentifierContext) IsLibraryIdentifierContext() {}

func NewLibraryIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryIdentifierContext {
	var p = new(LibraryIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_libraryIdentifier

	return p
}

func (s *LibraryIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LibraryIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterLibraryIdentifier(s)
	}
}

func (s *LibraryIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitLibraryIdentifier(s)
	}
}

func (p *cqlParser) LibraryIdentifier() (localctx ILibraryIdentifierContext) {
	this := p
	_ = this

	localctx = NewLibraryIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, cqlParserRULE_libraryIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(337)
		p.Identifier()
	}

	return localctx
}

// ICodeDefinitionContext is an interface to support dynamic dispatch.
type ICodeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	CodeId() ICodeIdContext
	CodesystemIdentifier() ICodesystemIdentifierContext
	AccessModifier() IAccessModifierContext
	DisplayClause() IDisplayClauseContext

	// IsCodeDefinitionContext differentiates from other interfaces.
	IsCodeDefinitionContext()
}

type CodeDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeDefinitionContext() *CodeDefinitionContext {
	var p = new(CodeDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_codeDefinition
	return p
}

func (*CodeDefinitionContext) IsCodeDefinitionContext() {}

func NewCodeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeDefinitionContext {
	var p = new(CodeDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_codeDefinition

	return p
}

func (s *CodeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CodeDefinitionContext) CodeId() ICodeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeIdContext)
}

func (s *CodeDefinitionContext) CodesystemIdentifier() ICodesystemIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodesystemIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodesystemIdentifierContext)
}

func (s *CodeDefinitionContext) AccessModifier() IAccessModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *CodeDefinitionContext) DisplayClause() IDisplayClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisplayClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisplayClauseContext)
}

func (s *CodeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterCodeDefinition(s)
	}
}

func (s *CodeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitCodeDefinition(s)
	}
}

func (p *cqlParser) CodeDefinition() (localctx ICodeDefinitionContext) {
	this := p
	_ = this

	localctx = NewCodeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, cqlParserRULE_codeDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(340)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cqlParserT__5 || _la == cqlParserT__6 {
		{
			p.SetState(339)
			p.AccessModifier()
		}

	}
	{
		p.SetState(342)
		p.Match(cqlParserT__17)
	}
	{
		p.SetState(343)
		p.Identifier()
	}
	{
		p.SetState(344)
		p.Match(cqlParserT__10)
	}
	{
		p.SetState(345)
		p.CodeId()
	}
	{
		p.SetState(346)
		p.Match(cqlParserT__18)
	}
	{
		p.SetState(347)
		p.CodesystemIdentifier()
	}
	p.SetState(349)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cqlParserT__149 {
		{
			p.SetState(348)
			p.DisplayClause()
		}

	}

	return localctx
}

// IConceptDefinitionContext is an interface to support dynamic dispatch.
type IConceptDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllCodeIdentifier() []ICodeIdentifierContext
	CodeIdentifier(i int) ICodeIdentifierContext
	AccessModifier() IAccessModifierContext
	DisplayClause() IDisplayClauseContext

	// IsConceptDefinitionContext differentiates from other interfaces.
	IsConceptDefinitionContext()
}

type ConceptDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConceptDefinitionContext() *ConceptDefinitionContext {
	var p = new(ConceptDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_conceptDefinition
	return p
}

func (*ConceptDefinitionContext) IsConceptDefinitionContext() {}

func NewConceptDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConceptDefinitionContext {
	var p = new(ConceptDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_conceptDefinition

	return p
}

func (s *ConceptDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConceptDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConceptDefinitionContext) AllCodeIdentifier() []ICodeIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICodeIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ICodeIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICodeIdentifierContext); ok {
			tst[i] = t.(ICodeIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ConceptDefinitionContext) CodeIdentifier(i int) ICodeIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeIdentifierContext)
}

func (s *ConceptDefinitionContext) AccessModifier() IAccessModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *ConceptDefinitionContext) DisplayClause() IDisplayClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisplayClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisplayClauseContext)
}

func (s *ConceptDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConceptDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConceptDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterConceptDefinition(s)
	}
}

func (s *ConceptDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitConceptDefinition(s)
	}
}

func (p *cqlParser) ConceptDefinition() (localctx IConceptDefinitionContext) {
	this := p
	_ = this

	localctx = NewConceptDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, cqlParserRULE_conceptDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(352)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cqlParserT__5 || _la == cqlParserT__6 {
		{
			p.SetState(351)
			p.AccessModifier()
		}

	}
	{
		p.SetState(354)
		p.Match(cqlParserT__19)
	}
	{
		p.SetState(355)
		p.Identifier()
	}
	{
		p.SetState(356)
		p.Match(cqlParserT__10)
	}
	{
		p.SetState(357)
		p.Match(cqlParserT__13)
	}
	{
		p.SetState(358)
		p.CodeIdentifier()
	}
	p.SetState(363)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cqlParserT__14 {
		{
			p.SetState(359)
			p.Match(cqlParserT__14)
		}
		{
			p.SetState(360)
			p.CodeIdentifier()
		}

		p.SetState(365)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(366)
		p.Match(cqlParserT__15)
	}
	p.SetState(368)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cqlParserT__149 {
		{
			p.SetState(367)
			p.DisplayClause()
		}

	}

	return localctx
}

// ICodeIdentifierContext is an interface to support dynamic dispatch.
type ICodeIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LibraryIdentifier() ILibraryIdentifierContext

	// IsCodeIdentifierContext differentiates from other interfaces.
	IsCodeIdentifierContext()
}

type CodeIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeIdentifierContext() *CodeIdentifierContext {
	var p = new(CodeIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_codeIdentifier
	return p
}

func (*CodeIdentifierContext) IsCodeIdentifierContext() {}

func NewCodeIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeIdentifierContext {
	var p = new(CodeIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_codeIdentifier

	return p
}

func (s *CodeIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CodeIdentifierContext) LibraryIdentifier() ILibraryIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryIdentifierContext)
}

func (s *CodeIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterCodeIdentifier(s)
	}
}

func (s *CodeIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitCodeIdentifier(s)
	}
}

func (p *cqlParser) CodeIdentifier() (localctx ICodeIdentifierContext) {
	this := p
	_ = this

	localctx = NewCodeIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, cqlParserRULE_codeIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(373)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(370)
			p.LibraryIdentifier()
		}
		{
			p.SetState(371)
			p.Match(cqlParserT__16)
		}

	}
	{
		p.SetState(375)
		p.Identifier()
	}

	return localctx
}

// ICodesystemIdContext is an interface to support dynamic dispatch.
type ICodesystemIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode

	// IsCodesystemIdContext differentiates from other interfaces.
	IsCodesystemIdContext()
}

type CodesystemIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodesystemIdContext() *CodesystemIdContext {
	var p = new(CodesystemIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_codesystemId
	return p
}

func (*CodesystemIdContext) IsCodesystemIdContext() {}

func NewCodesystemIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodesystemIdContext {
	var p = new(CodesystemIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_codesystemId

	return p
}

func (s *CodesystemIdContext) GetParser() antlr.Parser { return s.parser }

func (s *CodesystemIdContext) STRING() antlr.TerminalNode {
	return s.GetToken(cqlParserSTRING, 0)
}

func (s *CodesystemIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodesystemIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodesystemIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterCodesystemId(s)
	}
}

func (s *CodesystemIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitCodesystemId(s)
	}
}

func (p *cqlParser) CodesystemId() (localctx ICodesystemIdContext) {
	this := p
	_ = this

	localctx = NewCodesystemIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, cqlParserRULE_codesystemId)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(377)
		p.Match(cqlParserSTRING)
	}

	return localctx
}

// IValuesetIdContext is an interface to support dynamic dispatch.
type IValuesetIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode

	// IsValuesetIdContext differentiates from other interfaces.
	IsValuesetIdContext()
}

type ValuesetIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuesetIdContext() *ValuesetIdContext {
	var p = new(ValuesetIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_valuesetId
	return p
}

func (*ValuesetIdContext) IsValuesetIdContext() {}

func NewValuesetIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuesetIdContext {
	var p = new(ValuesetIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_valuesetId

	return p
}

func (s *ValuesetIdContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuesetIdContext) STRING() antlr.TerminalNode {
	return s.GetToken(cqlParserSTRING, 0)
}

func (s *ValuesetIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesetIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValuesetIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterValuesetId(s)
	}
}

func (s *ValuesetIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitValuesetId(s)
	}
}

func (p *cqlParser) ValuesetId() (localctx IValuesetIdContext) {
	this := p
	_ = this

	localctx = NewValuesetIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, cqlParserRULE_valuesetId)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(379)
		p.Match(cqlParserSTRING)
	}

	return localctx
}

// IVersionSpecifierContext is an interface to support dynamic dispatch.
type IVersionSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode

	// IsVersionSpecifierContext differentiates from other interfaces.
	IsVersionSpecifierContext()
}

type VersionSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVersionSpecifierContext() *VersionSpecifierContext {
	var p = new(VersionSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_versionSpecifier
	return p
}

func (*VersionSpecifierContext) IsVersionSpecifierContext() {}

func NewVersionSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VersionSpecifierContext {
	var p = new(VersionSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_versionSpecifier

	return p
}

func (s *VersionSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VersionSpecifierContext) STRING() antlr.TerminalNode {
	return s.GetToken(cqlParserSTRING, 0)
}

func (s *VersionSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VersionSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VersionSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterVersionSpecifier(s)
	}
}

func (s *VersionSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitVersionSpecifier(s)
	}
}

func (p *cqlParser) VersionSpecifier() (localctx IVersionSpecifierContext) {
	this := p
	_ = this

	localctx = NewVersionSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, cqlParserRULE_versionSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(381)
		p.Match(cqlParserSTRING)
	}

	return localctx
}

// ICodeIdContext is an interface to support dynamic dispatch.
type ICodeIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode

	// IsCodeIdContext differentiates from other interfaces.
	IsCodeIdContext()
}

type CodeIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeIdContext() *CodeIdContext {
	var p = new(CodeIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_codeId
	return p
}

func (*CodeIdContext) IsCodeIdContext() {}

func NewCodeIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeIdContext {
	var p = new(CodeIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_codeId

	return p
}

func (s *CodeIdContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeIdContext) STRING() antlr.TerminalNode {
	return s.GetToken(cqlParserSTRING, 0)
}

func (s *CodeIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterCodeId(s)
	}
}

func (s *CodeIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitCodeId(s)
	}
}

func (p *cqlParser) CodeId() (localctx ICodeIdContext) {
	this := p
	_ = this

	localctx = NewCodeIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, cqlParserRULE_codeId)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(383)
		p.Match(cqlParserSTRING)
	}

	return localctx
}

// ITypeSpecifierContext is an interface to support dynamic dispatch.
type ITypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NamedTypeSpecifier() INamedTypeSpecifierContext
	ListTypeSpecifier() IListTypeSpecifierContext
	IntervalTypeSpecifier() IIntervalTypeSpecifierContext
	TupleTypeSpecifier() ITupleTypeSpecifierContext
	ChoiceTypeSpecifier() IChoiceTypeSpecifierContext

	// IsTypeSpecifierContext differentiates from other interfaces.
	IsTypeSpecifierContext()
}

type TypeSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSpecifierContext() *TypeSpecifierContext {
	var p = new(TypeSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_typeSpecifier
	return p
}

func (*TypeSpecifierContext) IsTypeSpecifierContext() {}

func NewTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSpecifierContext {
	var p = new(TypeSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_typeSpecifier

	return p
}

func (s *TypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSpecifierContext) NamedTypeSpecifier() INamedTypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedTypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedTypeSpecifierContext)
}

func (s *TypeSpecifierContext) ListTypeSpecifier() IListTypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListTypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListTypeSpecifierContext)
}

func (s *TypeSpecifierContext) IntervalTypeSpecifier() IIntervalTypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeSpecifierContext)
}

func (s *TypeSpecifierContext) TupleTypeSpecifier() ITupleTypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleTypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleTypeSpecifierContext)
}

func (s *TypeSpecifierContext) ChoiceTypeSpecifier() IChoiceTypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChoiceTypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChoiceTypeSpecifierContext)
}

func (s *TypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterTypeSpecifier(s)
	}
}

func (s *TypeSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitTypeSpecifier(s)
	}
}

func (p *cqlParser) TypeSpecifier() (localctx ITypeSpecifierContext) {
	this := p
	_ = this

	localctx = NewTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, cqlParserRULE_typeSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(390)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case cqlParserT__0, cqlParserT__1, cqlParserT__2, cqlParserT__3, cqlParserT__4, cqlParserT__5, cqlParserT__6, cqlParserT__7, cqlParserT__8, cqlParserT__9, cqlParserT__11, cqlParserT__12, cqlParserT__17, cqlParserT__19, cqlParserT__26, cqlParserT__27, cqlParserT__28, cqlParserT__41, cqlParserT__46, cqlParserT__47, cqlParserT__48, cqlParserT__49, cqlParserT__50, cqlParserT__70, cqlParserT__72, cqlParserT__73, cqlParserT__75, cqlParserT__76, cqlParserT__77, cqlParserT__86, cqlParserT__87, cqlParserT__88, cqlParserT__101, cqlParserT__102, cqlParserT__104, cqlParserT__105, cqlParserT__106, cqlParserT__114, cqlParserT__115, cqlParserT__126, cqlParserT__127, cqlParserT__128, cqlParserT__129, cqlParserT__136, cqlParserT__137, cqlParserT__140, cqlParserT__144, cqlParserT__145, cqlParserT__149, cqlParserT__150, cqlParserT__151, cqlParserQUOTEDIDENTIFIER, cqlParserIDENTIFIER, cqlParserDELIMITEDIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(385)
			p.NamedTypeSpecifier()
		}

	case cqlParserT__20:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(386)
			p.ListTypeSpecifier()
		}

	case cqlParserT__23:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(387)
			p.IntervalTypeSpecifier()
		}

	case cqlParserT__24:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(388)
			p.TupleTypeSpecifier()
		}

	case cqlParserT__25:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(389)
			p.ChoiceTypeSpecifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INamedTypeSpecifierContext is an interface to support dynamic dispatch.
type INamedTypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReferentialOrTypeNameIdentifier() IReferentialOrTypeNameIdentifierContext
	AllQualifier() []IQualifierContext
	Qualifier(i int) IQualifierContext

	// IsNamedTypeSpecifierContext differentiates from other interfaces.
	IsNamedTypeSpecifierContext()
}

type NamedTypeSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedTypeSpecifierContext() *NamedTypeSpecifierContext {
	var p = new(NamedTypeSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_namedTypeSpecifier
	return p
}

func (*NamedTypeSpecifierContext) IsNamedTypeSpecifierContext() {}

func NewNamedTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedTypeSpecifierContext {
	var p = new(NamedTypeSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_namedTypeSpecifier

	return p
}

func (s *NamedTypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedTypeSpecifierContext) ReferentialOrTypeNameIdentifier() IReferentialOrTypeNameIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialOrTypeNameIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialOrTypeNameIdentifierContext)
}

func (s *NamedTypeSpecifierContext) AllQualifier() []IQualifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifierContext); ok {
			len++
		}
	}

	tst := make([]IQualifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifierContext); ok {
			tst[i] = t.(IQualifierContext)
			i++
		}
	}

	return tst
}

func (s *NamedTypeSpecifierContext) Qualifier(i int) IQualifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifierContext)
}

func (s *NamedTypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedTypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedTypeSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterNamedTypeSpecifier(s)
	}
}

func (s *NamedTypeSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitNamedTypeSpecifier(s)
	}
}

func (p *cqlParser) NamedTypeSpecifier() (localctx INamedTypeSpecifierContext) {
	this := p
	_ = this

	localctx = NewNamedTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, cqlParserRULE_namedTypeSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(397)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(392)
				p.Qualifier()
			}
			{
				p.SetState(393)
				p.Match(cqlParserT__16)
			}

		}
		p.SetState(399)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())
	}
	{
		p.SetState(400)
		p.ReferentialOrTypeNameIdentifier()
	}

	return localctx
}

// IModelIdentifierContext is an interface to support dynamic dispatch.
type IModelIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsModelIdentifierContext differentiates from other interfaces.
	IsModelIdentifierContext()
}

type ModelIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModelIdentifierContext() *ModelIdentifierContext {
	var p = new(ModelIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_modelIdentifier
	return p
}

func (*ModelIdentifierContext) IsModelIdentifierContext() {}

func NewModelIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModelIdentifierContext {
	var p = new(ModelIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_modelIdentifier

	return p
}

func (s *ModelIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModelIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModelIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModelIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModelIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterModelIdentifier(s)
	}
}

func (s *ModelIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitModelIdentifier(s)
	}
}

func (p *cqlParser) ModelIdentifier() (localctx IModelIdentifierContext) {
	this := p
	_ = this

	localctx = NewModelIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, cqlParserRULE_modelIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(402)
		p.Identifier()
	}

	return localctx
}

// IListTypeSpecifierContext is an interface to support dynamic dispatch.
type IListTypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeSpecifier() ITypeSpecifierContext

	// IsListTypeSpecifierContext differentiates from other interfaces.
	IsListTypeSpecifierContext()
}

type ListTypeSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListTypeSpecifierContext() *ListTypeSpecifierContext {
	var p = new(ListTypeSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_listTypeSpecifier
	return p
}

func (*ListTypeSpecifierContext) IsListTypeSpecifierContext() {}

func NewListTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListTypeSpecifierContext {
	var p = new(ListTypeSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_listTypeSpecifier

	return p
}

func (s *ListTypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ListTypeSpecifierContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *ListTypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListTypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListTypeSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterListTypeSpecifier(s)
	}
}

func (s *ListTypeSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitListTypeSpecifier(s)
	}
}

func (p *cqlParser) ListTypeSpecifier() (localctx IListTypeSpecifierContext) {
	this := p
	_ = this

	localctx = NewListTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, cqlParserRULE_listTypeSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(404)
		p.Match(cqlParserT__20)
	}
	{
		p.SetState(405)
		p.Match(cqlParserT__21)
	}
	{
		p.SetState(406)
		p.TypeSpecifier()
	}
	{
		p.SetState(407)
		p.Match(cqlParserT__22)
	}

	return localctx
}

// IIntervalTypeSpecifierContext is an interface to support dynamic dispatch.
type IIntervalTypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeSpecifier() ITypeSpecifierContext

	// IsIntervalTypeSpecifierContext differentiates from other interfaces.
	IsIntervalTypeSpecifierContext()
}

type IntervalTypeSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalTypeSpecifierContext() *IntervalTypeSpecifierContext {
	var p = new(IntervalTypeSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_intervalTypeSpecifier
	return p
}

func (*IntervalTypeSpecifierContext) IsIntervalTypeSpecifierContext() {}

func NewIntervalTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalTypeSpecifierContext {
	var p = new(IntervalTypeSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_intervalTypeSpecifier

	return p
}

func (s *IntervalTypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalTypeSpecifierContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *IntervalTypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalTypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalTypeSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterIntervalTypeSpecifier(s)
	}
}

func (s *IntervalTypeSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitIntervalTypeSpecifier(s)
	}
}

func (p *cqlParser) IntervalTypeSpecifier() (localctx IIntervalTypeSpecifierContext) {
	this := p
	_ = this

	localctx = NewIntervalTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, cqlParserRULE_intervalTypeSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(409)
		p.Match(cqlParserT__23)
	}
	{
		p.SetState(410)
		p.Match(cqlParserT__21)
	}
	{
		p.SetState(411)
		p.TypeSpecifier()
	}
	{
		p.SetState(412)
		p.Match(cqlParserT__22)
	}

	return localctx
}

// ITupleTypeSpecifierContext is an interface to support dynamic dispatch.
type ITupleTypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTupleElementDefinition() []ITupleElementDefinitionContext
	TupleElementDefinition(i int) ITupleElementDefinitionContext

	// IsTupleTypeSpecifierContext differentiates from other interfaces.
	IsTupleTypeSpecifierContext()
}

type TupleTypeSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleTypeSpecifierContext() *TupleTypeSpecifierContext {
	var p = new(TupleTypeSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_tupleTypeSpecifier
	return p
}

func (*TupleTypeSpecifierContext) IsTupleTypeSpecifierContext() {}

func NewTupleTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleTypeSpecifierContext {
	var p = new(TupleTypeSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_tupleTypeSpecifier

	return p
}

func (s *TupleTypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleTypeSpecifierContext) AllTupleElementDefinition() []ITupleElementDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITupleElementDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ITupleElementDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITupleElementDefinitionContext); ok {
			tst[i] = t.(ITupleElementDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *TupleTypeSpecifierContext) TupleElementDefinition(i int) ITupleElementDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleElementDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleElementDefinitionContext)
}

func (s *TupleTypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleTypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleTypeSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterTupleTypeSpecifier(s)
	}
}

func (s *TupleTypeSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitTupleTypeSpecifier(s)
	}
}

func (p *cqlParser) TupleTypeSpecifier() (localctx ITupleTypeSpecifierContext) {
	this := p
	_ = this

	localctx = NewTupleTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, cqlParserRULE_tupleTypeSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(414)
		p.Match(cqlParserT__24)
	}
	{
		p.SetState(415)
		p.Match(cqlParserT__13)
	}
	{
		p.SetState(416)
		p.TupleElementDefinition()
	}
	p.SetState(421)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cqlParserT__14 {
		{
			p.SetState(417)
			p.Match(cqlParserT__14)
		}
		{
			p.SetState(418)
			p.TupleElementDefinition()
		}

		p.SetState(423)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(424)
		p.Match(cqlParserT__15)
	}

	return localctx
}

// ITupleElementDefinitionContext is an interface to support dynamic dispatch.
type ITupleElementDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReferentialIdentifier() IReferentialIdentifierContext
	TypeSpecifier() ITypeSpecifierContext

	// IsTupleElementDefinitionContext differentiates from other interfaces.
	IsTupleElementDefinitionContext()
}

type TupleElementDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleElementDefinitionContext() *TupleElementDefinitionContext {
	var p = new(TupleElementDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_tupleElementDefinition
	return p
}

func (*TupleElementDefinitionContext) IsTupleElementDefinitionContext() {}

func NewTupleElementDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleElementDefinitionContext {
	var p = new(TupleElementDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_tupleElementDefinition

	return p
}

func (s *TupleElementDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleElementDefinitionContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}

func (s *TupleElementDefinitionContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *TupleElementDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleElementDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleElementDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterTupleElementDefinition(s)
	}
}

func (s *TupleElementDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitTupleElementDefinition(s)
	}
}

func (p *cqlParser) TupleElementDefinition() (localctx ITupleElementDefinitionContext) {
	this := p
	_ = this

	localctx = NewTupleElementDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, cqlParserRULE_tupleElementDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(426)
		p.ReferentialIdentifier()
	}
	{
		p.SetState(427)
		p.TypeSpecifier()
	}

	return localctx
}

// IChoiceTypeSpecifierContext is an interface to support dynamic dispatch.
type IChoiceTypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeSpecifier() []ITypeSpecifierContext
	TypeSpecifier(i int) ITypeSpecifierContext

	// IsChoiceTypeSpecifierContext differentiates from other interfaces.
	IsChoiceTypeSpecifierContext()
}

type ChoiceTypeSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChoiceTypeSpecifierContext() *ChoiceTypeSpecifierContext {
	var p = new(ChoiceTypeSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_choiceTypeSpecifier
	return p
}

func (*ChoiceTypeSpecifierContext) IsChoiceTypeSpecifierContext() {}

func NewChoiceTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChoiceTypeSpecifierContext {
	var p = new(ChoiceTypeSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_choiceTypeSpecifier

	return p
}

func (s *ChoiceTypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ChoiceTypeSpecifierContext) AllTypeSpecifier() []ITypeSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			len++
		}
	}

	tst := make([]ITypeSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeSpecifierContext); ok {
			tst[i] = t.(ITypeSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *ChoiceTypeSpecifierContext) TypeSpecifier(i int) ITypeSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *ChoiceTypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChoiceTypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChoiceTypeSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterChoiceTypeSpecifier(s)
	}
}

func (s *ChoiceTypeSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitChoiceTypeSpecifier(s)
	}
}

func (p *cqlParser) ChoiceTypeSpecifier() (localctx IChoiceTypeSpecifierContext) {
	this := p
	_ = this

	localctx = NewChoiceTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, cqlParserRULE_choiceTypeSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(429)
		p.Match(cqlParserT__25)
	}
	{
		p.SetState(430)
		p.Match(cqlParserT__21)
	}
	{
		p.SetState(431)
		p.TypeSpecifier()
	}
	p.SetState(436)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cqlParserT__14 {
		{
			p.SetState(432)
			p.Match(cqlParserT__14)
		}
		{
			p.SetState(433)
			p.TypeSpecifier()
		}

		p.SetState(438)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(439)
		p.Match(cqlParserT__22)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionDefinition() IExpressionDefinitionContext
	ContextDefinition() IContextDefinitionContext
	FunctionDefinition() IFunctionDefinitionContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) ExpressionDefinition() IExpressionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionDefinitionContext)
}

func (s *StatementContext) ContextDefinition() IContextDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContextDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContextDefinitionContext)
}

func (s *StatementContext) FunctionDefinition() IFunctionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDefinitionContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *cqlParser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, cqlParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(444)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(441)
			p.ExpressionDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(442)
			p.ContextDefinition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(443)
			p.FunctionDefinition()
		}

	}

	return localctx
}

// IExpressionDefinitionContext is an interface to support dynamic dispatch.
type IExpressionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Expression() IExpressionContext
	AccessModifier() IAccessModifierContext

	// IsExpressionDefinitionContext differentiates from other interfaces.
	IsExpressionDefinitionContext()
}

type ExpressionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionDefinitionContext() *ExpressionDefinitionContext {
	var p = new(ExpressionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_expressionDefinition
	return p
}

func (*ExpressionDefinitionContext) IsExpressionDefinitionContext() {}

func NewExpressionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionDefinitionContext {
	var p = new(ExpressionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_expressionDefinition

	return p
}

func (s *ExpressionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExpressionDefinitionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionDefinitionContext) AccessModifier() IAccessModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *ExpressionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterExpressionDefinition(s)
	}
}

func (s *ExpressionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitExpressionDefinition(s)
	}
}

func (p *cqlParser) ExpressionDefinition() (localctx IExpressionDefinitionContext) {
	this := p
	_ = this

	localctx = NewExpressionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, cqlParserRULE_expressionDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(446)
		p.Match(cqlParserT__26)
	}
	p.SetState(448)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cqlParserT__5 || _la == cqlParserT__6 {
		{
			p.SetState(447)
			p.AccessModifier()
		}

	}
	{
		p.SetState(450)
		p.Identifier()
	}
	{
		p.SetState(451)
		p.Match(cqlParserT__10)
	}
	{
		p.SetState(452)
		p.expression(0)
	}

	return localctx
}

// IContextDefinitionContext is an interface to support dynamic dispatch.
type IContextDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ModelIdentifier() IModelIdentifierContext

	// IsContextDefinitionContext differentiates from other interfaces.
	IsContextDefinitionContext()
}

type ContextDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContextDefinitionContext() *ContextDefinitionContext {
	var p = new(ContextDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_contextDefinition
	return p
}

func (*ContextDefinitionContext) IsContextDefinitionContext() {}

func NewContextDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContextDefinitionContext {
	var p = new(ContextDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_contextDefinition

	return p
}

func (s *ContextDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ContextDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ContextDefinitionContext) ModelIdentifier() IModelIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModelIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModelIdentifierContext)
}

func (s *ContextDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContextDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContextDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterContextDefinition(s)
	}
}

func (s *ContextDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitContextDefinition(s)
	}
}

func (p *cqlParser) ContextDefinition() (localctx IContextDefinitionContext) {
	this := p
	_ = this

	localctx = NewContextDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, cqlParserRULE_contextDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(454)
		p.Match(cqlParserT__27)
	}
	p.SetState(458)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(455)
			p.ModelIdentifier()
		}
		{
			p.SetState(456)
			p.Match(cqlParserT__16)
		}

	}
	{
		p.SetState(460)
		p.Identifier()
	}

	return localctx
}

// IFunctionDefinitionContext is an interface to support dynamic dispatch.
type IFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierOrFunctionIdentifier() IIdentifierOrFunctionIdentifierContext
	FunctionBody() IFunctionBodyContext
	AccessModifier() IAccessModifierContext
	AllOperandDefinition() []IOperandDefinitionContext
	OperandDefinition(i int) IOperandDefinitionContext
	TypeSpecifier() ITypeSpecifierContext

	// IsFunctionDefinitionContext differentiates from other interfaces.
	IsFunctionDefinitionContext()
}

type FunctionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDefinitionContext() *FunctionDefinitionContext {
	var p = new(FunctionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_functionDefinition
	return p
}

func (*FunctionDefinitionContext) IsFunctionDefinitionContext() {}

func NewFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDefinitionContext {
	var p = new(FunctionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_functionDefinition

	return p
}

func (s *FunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDefinitionContext) IdentifierOrFunctionIdentifier() IIdentifierOrFunctionIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrFunctionIdentifierContext)
}

func (s *FunctionDefinitionContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionDefinitionContext) AccessModifier() IAccessModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *FunctionDefinitionContext) AllOperandDefinition() []IOperandDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOperandDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IOperandDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOperandDefinitionContext); ok {
			tst[i] = t.(IOperandDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *FunctionDefinitionContext) OperandDefinition(i int) IOperandDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperandDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperandDefinitionContext)
}

func (s *FunctionDefinitionContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *FunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterFunctionDefinition(s)
	}
}

func (s *FunctionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitFunctionDefinition(s)
	}
}

func (p *cqlParser) FunctionDefinition() (localctx IFunctionDefinitionContext) {
	this := p
	_ = this

	localctx = NewFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, cqlParserRULE_functionDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(462)
		p.Match(cqlParserT__26)
	}
	p.SetState(464)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cqlParserT__5 || _la == cqlParserT__6 {
		{
			p.SetState(463)
			p.AccessModifier()
		}

	}
	{
		p.SetState(466)
		p.Match(cqlParserT__28)
	}
	{
		p.SetState(467)
		p.IdentifierOrFunctionIdentifier()
	}
	{
		p.SetState(468)
		p.Match(cqlParserT__29)
	}
	p.SetState(477)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4367261126375422) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&1080916813829046509) != 0) || ((int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&3285779) != 0) {
		{
			p.SetState(469)
			p.OperandDefinition()
		}
		p.SetState(474)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == cqlParserT__14 {
			{
				p.SetState(470)
				p.Match(cqlParserT__14)
			}
			{
				p.SetState(471)
				p.OperandDefinition()
			}

			p.SetState(476)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(479)
		p.Match(cqlParserT__30)
	}
	p.SetState(482)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cqlParserT__31 {
		{
			p.SetState(480)
			p.Match(cqlParserT__31)
		}
		{
			p.SetState(481)
			p.TypeSpecifier()
		}

	}
	{
		p.SetState(484)
		p.Match(cqlParserT__10)
	}
	p.SetState(487)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case cqlParserT__0, cqlParserT__1, cqlParserT__2, cqlParserT__3, cqlParserT__4, cqlParserT__5, cqlParserT__6, cqlParserT__7, cqlParserT__8, cqlParserT__9, cqlParserT__11, cqlParserT__12, cqlParserT__13, cqlParserT__17, cqlParserT__18, cqlParserT__19, cqlParserT__20, cqlParserT__23, cqlParserT__24, cqlParserT__26, cqlParserT__27, cqlParserT__28, cqlParserT__29, cqlParserT__36, cqlParserT__41, cqlParserT__44, cqlParserT__46, cqlParserT__47, cqlParserT__48, cqlParserT__49, cqlParserT__50, cqlParserT__52, cqlParserT__53, cqlParserT__54, cqlParserT__55, cqlParserT__57, cqlParserT__58, cqlParserT__62, cqlParserT__63, cqlParserT__70, cqlParserT__72, cqlParserT__73, cqlParserT__75, cqlParserT__76, cqlParserT__77, cqlParserT__78, cqlParserT__79, cqlParserT__80, cqlParserT__81, cqlParserT__82, cqlParserT__83, cqlParserT__84, cqlParserT__85, cqlParserT__86, cqlParserT__87, cqlParserT__88, cqlParserT__89, cqlParserT__90, cqlParserT__91, cqlParserT__92, cqlParserT__93, cqlParserT__94, cqlParserT__95, cqlParserT__96, cqlParserT__97, cqlParserT__99, cqlParserT__100, cqlParserT__101, cqlParserT__102, cqlParserT__104, cqlParserT__105, cqlParserT__106, cqlParserT__107, cqlParserT__108, cqlParserT__109, cqlParserT__110, cqlParserT__114, cqlParserT__115, cqlParserT__117, cqlParserT__120, cqlParserT__121, cqlParserT__122, cqlParserT__123, cqlParserT__126, cqlParserT__127, cqlParserT__128, cqlParserT__129, cqlParserT__136, cqlParserT__137, cqlParserT__140, cqlParserT__144, cqlParserT__145, cqlParserT__146, cqlParserT__147, cqlParserT__148, cqlParserT__149, cqlParserT__150, cqlParserT__151, cqlParserT__152, cqlParserQUOTEDIDENTIFIER, cqlParserDATETIME, cqlParserTIME, cqlParserIDENTIFIER, cqlParserDELIMITEDIDENTIFIER, cqlParserSTRING, cqlParserNUMBER:
		{
			p.SetState(485)
			p.FunctionBody()
		}

	case cqlParserT__32:
		{
			p.SetState(486)
			p.Match(cqlParserT__32)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOperandDefinitionContext is an interface to support dynamic dispatch.
type IOperandDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReferentialIdentifier() IReferentialIdentifierContext
	TypeSpecifier() ITypeSpecifierContext

	// IsOperandDefinitionContext differentiates from other interfaces.
	IsOperandDefinitionContext()
}

type OperandDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperandDefinitionContext() *OperandDefinitionContext {
	var p = new(OperandDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_operandDefinition
	return p
}

func (*OperandDefinitionContext) IsOperandDefinitionContext() {}

func NewOperandDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperandDefinitionContext {
	var p = new(OperandDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_operandDefinition

	return p
}

func (s *OperandDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *OperandDefinitionContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}

func (s *OperandDefinitionContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *OperandDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperandDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperandDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterOperandDefinition(s)
	}
}

func (s *OperandDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitOperandDefinition(s)
	}
}

func (p *cqlParser) OperandDefinition() (localctx IOperandDefinitionContext) {
	this := p
	_ = this

	localctx = NewOperandDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, cqlParserRULE_operandDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(489)
		p.ReferentialIdentifier()
	}
	{
		p.SetState(490)
		p.TypeSpecifier()
	}

	return localctx
}

// IFunctionBodyContext is an interface to support dynamic dispatch.
type IFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsFunctionBodyContext differentiates from other interfaces.
	IsFunctionBodyContext()
}

type FunctionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionBodyContext() *FunctionBodyContext {
	var p = new(FunctionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_functionBody
	return p
}

func (*FunctionBodyContext) IsFunctionBodyContext() {}

func NewFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionBodyContext {
	var p = new(FunctionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_functionBody

	return p
}

func (s *FunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionBodyContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterFunctionBody(s)
	}
}

func (s *FunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitFunctionBody(s)
	}
}

func (p *cqlParser) FunctionBody() (localctx IFunctionBodyContext) {
	this := p
	_ = this

	localctx = NewFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, cqlParserRULE_functionBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(492)
		p.expression(0)
	}

	return localctx
}

// IQuerySourceContext is an interface to support dynamic dispatch.
type IQuerySourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Retrieve() IRetrieveContext
	QualifiedIdentifierExpression() IQualifiedIdentifierExpressionContext
	Expression() IExpressionContext

	// IsQuerySourceContext differentiates from other interfaces.
	IsQuerySourceContext()
}

type QuerySourceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySourceContext() *QuerySourceContext {
	var p = new(QuerySourceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_querySource
	return p
}

func (*QuerySourceContext) IsQuerySourceContext() {}

func NewQuerySourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySourceContext {
	var p = new(QuerySourceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_querySource

	return p
}

func (s *QuerySourceContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySourceContext) Retrieve() IRetrieveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRetrieveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRetrieveContext)
}

func (s *QuerySourceContext) QualifiedIdentifierExpression() IQualifiedIdentifierExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierExpressionContext)
}

func (s *QuerySourceContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *QuerySourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterQuerySource(s)
	}
}

func (s *QuerySourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitQuerySource(s)
	}
}

func (p *cqlParser) QuerySource() (localctx IQuerySourceContext) {
	this := p
	_ = this

	localctx = NewQuerySourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, cqlParserRULE_querySource)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(500)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case cqlParserT__36:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(494)
			p.Retrieve()
		}

	case cqlParserT__0, cqlParserT__1, cqlParserT__2, cqlParserT__3, cqlParserT__4, cqlParserT__5, cqlParserT__6, cqlParserT__7, cqlParserT__8, cqlParserT__9, cqlParserT__11, cqlParserT__12, cqlParserT__17, cqlParserT__19, cqlParserT__26, cqlParserT__27, cqlParserT__28, cqlParserT__41, cqlParserT__46, cqlParserT__47, cqlParserT__48, cqlParserT__49, cqlParserT__50, cqlParserT__70, cqlParserT__72, cqlParserT__73, cqlParserT__75, cqlParserT__76, cqlParserT__77, cqlParserT__86, cqlParserT__87, cqlParserT__88, cqlParserT__101, cqlParserT__102, cqlParserT__104, cqlParserT__105, cqlParserT__106, cqlParserT__114, cqlParserT__115, cqlParserT__126, cqlParserT__127, cqlParserT__128, cqlParserT__129, cqlParserT__136, cqlParserT__137, cqlParserT__140, cqlParserT__144, cqlParserT__145, cqlParserT__149, cqlParserQUOTEDIDENTIFIER, cqlParserIDENTIFIER, cqlParserDELIMITEDIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(495)
			p.QualifiedIdentifierExpression()
		}

	case cqlParserT__29:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(496)
			p.Match(cqlParserT__29)
		}
		{
			p.SetState(497)
			p.expression(0)
		}
		{
			p.SetState(498)
			p.Match(cqlParserT__30)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAliasedQuerySourceContext is an interface to support dynamic dispatch.
type IAliasedQuerySourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QuerySource() IQuerySourceContext
	Alias() IAliasContext

	// IsAliasedQuerySourceContext differentiates from other interfaces.
	IsAliasedQuerySourceContext()
}

type AliasedQuerySourceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasedQuerySourceContext() *AliasedQuerySourceContext {
	var p = new(AliasedQuerySourceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_aliasedQuerySource
	return p
}

func (*AliasedQuerySourceContext) IsAliasedQuerySourceContext() {}

func NewAliasedQuerySourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasedQuerySourceContext {
	var p = new(AliasedQuerySourceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_aliasedQuerySource

	return p
}

func (s *AliasedQuerySourceContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasedQuerySourceContext) QuerySource() IQuerySourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySourceContext)
}

func (s *AliasedQuerySourceContext) Alias() IAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *AliasedQuerySourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasedQuerySourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasedQuerySourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterAliasedQuerySource(s)
	}
}

func (s *AliasedQuerySourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitAliasedQuerySource(s)
	}
}

func (p *cqlParser) AliasedQuerySource() (localctx IAliasedQuerySourceContext) {
	this := p
	_ = this

	localctx = NewAliasedQuerySourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, cqlParserRULE_aliasedQuerySource)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(502)
		p.QuerySource()
	}
	{
		p.SetState(503)
		p.Alias()
	}

	return localctx
}

// IAliasContext is an interface to support dynamic dispatch.
type IAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsAliasContext differentiates from other interfaces.
	IsAliasContext()
}

type AliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasContext() *AliasContext {
	var p = new(AliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_alias
	return p
}

func (*AliasContext) IsAliasContext() {}

func NewAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasContext {
	var p = new(AliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_alias

	return p
}

func (s *AliasContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterAlias(s)
	}
}

func (s *AliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitAlias(s)
	}
}

func (p *cqlParser) Alias() (localctx IAliasContext) {
	this := p
	_ = this

	localctx = NewAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, cqlParserRULE_alias)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(505)
		p.Identifier()
	}

	return localctx
}

// IQueryInclusionClauseContext is an interface to support dynamic dispatch.
type IQueryInclusionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WithClause() IWithClauseContext
	WithoutClause() IWithoutClauseContext

	// IsQueryInclusionClauseContext differentiates from other interfaces.
	IsQueryInclusionClauseContext()
}

type QueryInclusionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryInclusionClauseContext() *QueryInclusionClauseContext {
	var p = new(QueryInclusionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_queryInclusionClause
	return p
}

func (*QueryInclusionClauseContext) IsQueryInclusionClauseContext() {}

func NewQueryInclusionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryInclusionClauseContext {
	var p = new(QueryInclusionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_queryInclusionClause

	return p
}

func (s *QueryInclusionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryInclusionClauseContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *QueryInclusionClauseContext) WithoutClause() IWithoutClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithoutClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithoutClauseContext)
}

func (s *QueryInclusionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryInclusionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryInclusionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterQueryInclusionClause(s)
	}
}

func (s *QueryInclusionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitQueryInclusionClause(s)
	}
}

func (p *cqlParser) QueryInclusionClause() (localctx IQueryInclusionClauseContext) {
	this := p
	_ = this

	localctx = NewQueryInclusionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, cqlParserRULE_queryInclusionClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(509)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case cqlParserT__33:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(507)
			p.WithClause()
		}

	case cqlParserT__35:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(508)
			p.WithoutClause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AliasedQuerySource() IAliasedQuerySourceContext
	Expression() IExpressionContext

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_withClause
	return p
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) AliasedQuerySource() IAliasedQuerySourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasedQuerySourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasedQuerySourceContext)
}

func (s *WithClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterWithClause(s)
	}
}

func (s *WithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitWithClause(s)
	}
}

func (p *cqlParser) WithClause() (localctx IWithClauseContext) {
	this := p
	_ = this

	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, cqlParserRULE_withClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(511)
		p.Match(cqlParserT__33)
	}
	{
		p.SetState(512)
		p.AliasedQuerySource()
	}
	{
		p.SetState(513)
		p.Match(cqlParserT__34)
	}
	{
		p.SetState(514)
		p.expression(0)
	}

	return localctx
}

// IWithoutClauseContext is an interface to support dynamic dispatch.
type IWithoutClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AliasedQuerySource() IAliasedQuerySourceContext
	Expression() IExpressionContext

	// IsWithoutClauseContext differentiates from other interfaces.
	IsWithoutClauseContext()
}

type WithoutClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithoutClauseContext() *WithoutClauseContext {
	var p = new(WithoutClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_withoutClause
	return p
}

func (*WithoutClauseContext) IsWithoutClauseContext() {}

func NewWithoutClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithoutClauseContext {
	var p = new(WithoutClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_withoutClause

	return p
}

func (s *WithoutClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithoutClauseContext) AliasedQuerySource() IAliasedQuerySourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasedQuerySourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasedQuerySourceContext)
}

func (s *WithoutClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WithoutClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithoutClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithoutClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterWithoutClause(s)
	}
}

func (s *WithoutClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitWithoutClause(s)
	}
}

func (p *cqlParser) WithoutClause() (localctx IWithoutClauseContext) {
	this := p
	_ = this

	localctx = NewWithoutClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, cqlParserRULE_withoutClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(516)
		p.Match(cqlParserT__35)
	}
	{
		p.SetState(517)
		p.AliasedQuerySource()
	}
	{
		p.SetState(518)
		p.Match(cqlParserT__34)
	}
	{
		p.SetState(519)
		p.expression(0)
	}

	return localctx
}

// IRetrieveContext is an interface to support dynamic dispatch.
type IRetrieveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NamedTypeSpecifier() INamedTypeSpecifierContext
	ContextIdentifier() IContextIdentifierContext
	Terminology() ITerminologyContext
	CodePath() ICodePathContext

	// IsRetrieveContext differentiates from other interfaces.
	IsRetrieveContext()
}

type RetrieveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRetrieveContext() *RetrieveContext {
	var p = new(RetrieveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_retrieve
	return p
}

func (*RetrieveContext) IsRetrieveContext() {}

func NewRetrieveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RetrieveContext {
	var p = new(RetrieveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_retrieve

	return p
}

func (s *RetrieveContext) GetParser() antlr.Parser { return s.parser }

func (s *RetrieveContext) NamedTypeSpecifier() INamedTypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedTypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedTypeSpecifierContext)
}

func (s *RetrieveContext) ContextIdentifier() IContextIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContextIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContextIdentifierContext)
}

func (s *RetrieveContext) Terminology() ITerminologyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITerminologyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITerminologyContext)
}

func (s *RetrieveContext) CodePath() ICodePathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodePathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodePathContext)
}

func (s *RetrieveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RetrieveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RetrieveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterRetrieve(s)
	}
}

func (s *RetrieveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitRetrieve(s)
	}
}

func (p *cqlParser) Retrieve() (localctx IRetrieveContext) {
	this := p
	_ = this

	localctx = NewRetrieveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, cqlParserRULE_retrieve)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(521)
		p.Match(cqlParserT__36)
	}
	p.SetState(525)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(522)
			p.ContextIdentifier()
		}
		{
			p.SetState(523)
			p.Match(cqlParserT__37)
		}

	}
	{
		p.SetState(527)
		p.NamedTypeSpecifier()
	}
	p.SetState(535)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cqlParserT__10 {
		{
			p.SetState(528)
			p.Match(cqlParserT__10)
		}
		p.SetState(532)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(529)
				p.CodePath()
			}
			{
				p.SetState(530)
				p.Match(cqlParserT__38)
			}

		}
		{
			p.SetState(534)
			p.Terminology()
		}

	}
	{
		p.SetState(537)
		p.Match(cqlParserT__39)
	}

	return localctx
}

// IContextIdentifierContext is an interface to support dynamic dispatch.
type IContextIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifierExpression() IQualifiedIdentifierExpressionContext

	// IsContextIdentifierContext differentiates from other interfaces.
	IsContextIdentifierContext()
}

type ContextIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContextIdentifierContext() *ContextIdentifierContext {
	var p = new(ContextIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_contextIdentifier
	return p
}

func (*ContextIdentifierContext) IsContextIdentifierContext() {}

func NewContextIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContextIdentifierContext {
	var p = new(ContextIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_contextIdentifier

	return p
}

func (s *ContextIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ContextIdentifierContext) QualifiedIdentifierExpression() IQualifiedIdentifierExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierExpressionContext)
}

func (s *ContextIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContextIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContextIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterContextIdentifier(s)
	}
}

func (s *ContextIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitContextIdentifier(s)
	}
}

func (p *cqlParser) ContextIdentifier() (localctx IContextIdentifierContext) {
	this := p
	_ = this

	localctx = NewContextIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, cqlParserRULE_contextIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(539)
		p.QualifiedIdentifierExpression()
	}

	return localctx
}

// ICodePathContext is an interface to support dynamic dispatch.
type ICodePathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimplePath() ISimplePathContext

	// IsCodePathContext differentiates from other interfaces.
	IsCodePathContext()
}

type CodePathContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodePathContext() *CodePathContext {
	var p = new(CodePathContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_codePath
	return p
}

func (*CodePathContext) IsCodePathContext() {}

func NewCodePathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodePathContext {
	var p = new(CodePathContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_codePath

	return p
}

func (s *CodePathContext) GetParser() antlr.Parser { return s.parser }

func (s *CodePathContext) SimplePath() ISimplePathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplePathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplePathContext)
}

func (s *CodePathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodePathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodePathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterCodePath(s)
	}
}

func (s *CodePathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitCodePath(s)
	}
}

func (p *cqlParser) CodePath() (localctx ICodePathContext) {
	this := p
	_ = this

	localctx = NewCodePathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, cqlParserRULE_codePath)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(541)
		p.simplePath(0)
	}

	return localctx
}

// ITerminologyContext is an interface to support dynamic dispatch.
type ITerminologyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifierExpression() IQualifiedIdentifierExpressionContext
	Expression() IExpressionContext

	// IsTerminologyContext differentiates from other interfaces.
	IsTerminologyContext()
}

type TerminologyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTerminologyContext() *TerminologyContext {
	var p = new(TerminologyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_terminology
	return p
}

func (*TerminologyContext) IsTerminologyContext() {}

func NewTerminologyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TerminologyContext {
	var p = new(TerminologyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_terminology

	return p
}

func (s *TerminologyContext) GetParser() antlr.Parser { return s.parser }

func (s *TerminologyContext) QualifiedIdentifierExpression() IQualifiedIdentifierExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierExpressionContext)
}

func (s *TerminologyContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TerminologyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TerminologyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TerminologyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterTerminology(s)
	}
}

func (s *TerminologyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitTerminology(s)
	}
}

func (p *cqlParser) Terminology() (localctx ITerminologyContext) {
	this := p
	_ = this

	localctx = NewTerminologyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, cqlParserRULE_terminology)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(545)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(543)
			p.QualifiedIdentifierExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(544)
			p.expression(0)
		}

	}

	return localctx
}

// IQualifierContext is an interface to support dynamic dispatch.
type IQualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsQualifierContext differentiates from other interfaces.
	IsQualifierContext()
}

type QualifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifierContext() *QualifierContext {
	var p = new(QualifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_qualifier
	return p
}

func (*QualifierContext) IsQualifierContext() {}

func NewQualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifierContext {
	var p = new(QualifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_qualifier

	return p
}

func (s *QualifierContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterQualifier(s)
	}
}

func (s *QualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitQualifier(s)
	}
}

func (p *cqlParser) Qualifier() (localctx IQualifierContext) {
	this := p
	_ = this

	localctx = NewQualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, cqlParserRULE_qualifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(547)
		p.Identifier()
	}

	return localctx
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SourceClause() ISourceClauseContext
	LetClause() ILetClauseContext
	AllQueryInclusionClause() []IQueryInclusionClauseContext
	QueryInclusionClause(i int) IQueryInclusionClauseContext
	WhereClause() IWhereClauseContext
	ReturnClause() IReturnClauseContext
	SortClause() ISortClauseContext

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_query
	return p
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) SourceClause() ISourceClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceClauseContext)
}

func (s *QueryContext) LetClause() ILetClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetClauseContext)
}

func (s *QueryContext) AllQueryInclusionClause() []IQueryInclusionClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryInclusionClauseContext); ok {
			len++
		}
	}

	tst := make([]IQueryInclusionClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryInclusionClauseContext); ok {
			tst[i] = t.(IQueryInclusionClauseContext)
			i++
		}
	}

	return tst
}

func (s *QueryContext) QueryInclusionClause(i int) IQueryInclusionClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryInclusionClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryInclusionClauseContext)
}

func (s *QueryContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *QueryContext) ReturnClause() IReturnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnClauseContext)
}

func (s *QueryContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (p *cqlParser) Query() (localctx IQueryContext) {
	this := p
	_ = this

	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, cqlParserRULE_query)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(549)
		p.SourceClause()
	}
	p.SetState(551)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(550)
			p.LetClause()
		}

	}
	p.SetState(556)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(553)
				p.QueryInclusionClause()
			}

		}
		p.SetState(558)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext())
	}
	p.SetState(560)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(559)
			p.WhereClause()
		}

	}
	p.SetState(563)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(562)
			p.ReturnClause()
		}

	}
	p.SetState(566)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(565)
			p.SortClause()
		}

	}

	return localctx
}

// ISourceClauseContext is an interface to support dynamic dispatch.
type ISourceClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAliasedQuerySource() []IAliasedQuerySourceContext
	AliasedQuerySource(i int) IAliasedQuerySourceContext

	// IsSourceClauseContext differentiates from other interfaces.
	IsSourceClauseContext()
}

type SourceClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceClauseContext() *SourceClauseContext {
	var p = new(SourceClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_sourceClause
	return p
}

func (*SourceClauseContext) IsSourceClauseContext() {}

func NewSourceClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceClauseContext {
	var p = new(SourceClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_sourceClause

	return p
}

func (s *SourceClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceClauseContext) AllAliasedQuerySource() []IAliasedQuerySourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAliasedQuerySourceContext); ok {
			len++
		}
	}

	tst := make([]IAliasedQuerySourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAliasedQuerySourceContext); ok {
			tst[i] = t.(IAliasedQuerySourceContext)
			i++
		}
	}

	return tst
}

func (s *SourceClauseContext) AliasedQuerySource(i int) IAliasedQuerySourceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasedQuerySourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasedQuerySourceContext)
}

func (s *SourceClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterSourceClause(s)
	}
}

func (s *SourceClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitSourceClause(s)
	}
}

func (p *cqlParser) SourceClause() (localctx ISourceClauseContext) {
	this := p
	_ = this

	localctx = NewSourceClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, cqlParserRULE_sourceClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(569)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cqlParserT__18 {
		{
			p.SetState(568)
			p.Match(cqlParserT__18)
		}

	}
	{
		p.SetState(571)
		p.AliasedQuerySource()
	}
	p.SetState(576)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(572)
				p.Match(cqlParserT__14)
			}
			{
				p.SetState(573)
				p.AliasedQuerySource()
			}

		}
		p.SetState(578)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext())
	}

	return localctx
}

// ILetClauseContext is an interface to support dynamic dispatch.
type ILetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLetClauseItem() []ILetClauseItemContext
	LetClauseItem(i int) ILetClauseItemContext

	// IsLetClauseContext differentiates from other interfaces.
	IsLetClauseContext()
}

type LetClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetClauseContext() *LetClauseContext {
	var p = new(LetClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_letClause
	return p
}

func (*LetClauseContext) IsLetClauseContext() {}

func NewLetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetClauseContext {
	var p = new(LetClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_letClause

	return p
}

func (s *LetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LetClauseContext) AllLetClauseItem() []ILetClauseItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILetClauseItemContext); ok {
			len++
		}
	}

	tst := make([]ILetClauseItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILetClauseItemContext); ok {
			tst[i] = t.(ILetClauseItemContext)
			i++
		}
	}

	return tst
}

func (s *LetClauseContext) LetClauseItem(i int) ILetClauseItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetClauseItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetClauseItemContext)
}

func (s *LetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterLetClause(s)
	}
}

func (s *LetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitLetClause(s)
	}
}

func (p *cqlParser) LetClause() (localctx ILetClauseContext) {
	this := p
	_ = this

	localctx = NewLetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, cqlParserRULE_letClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(579)
		p.Match(cqlParserT__40)
	}
	{
		p.SetState(580)
		p.LetClauseItem()
	}
	p.SetState(585)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(581)
				p.Match(cqlParserT__14)
			}
			{
				p.SetState(582)
				p.LetClauseItem()
			}

		}
		p.SetState(587)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext())
	}

	return localctx
}

// ILetClauseItemContext is an interface to support dynamic dispatch.
type ILetClauseItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Expression() IExpressionContext

	// IsLetClauseItemContext differentiates from other interfaces.
	IsLetClauseItemContext()
}

type LetClauseItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetClauseItemContext() *LetClauseItemContext {
	var p = new(LetClauseItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_letClauseItem
	return p
}

func (*LetClauseItemContext) IsLetClauseItemContext() {}

func NewLetClauseItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetClauseItemContext {
	var p = new(LetClauseItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_letClauseItem

	return p
}

func (s *LetClauseItemContext) GetParser() antlr.Parser { return s.parser }

func (s *LetClauseItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LetClauseItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LetClauseItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetClauseItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetClauseItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterLetClauseItem(s)
	}
}

func (s *LetClauseItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitLetClauseItem(s)
	}
}

func (p *cqlParser) LetClauseItem() (localctx ILetClauseItemContext) {
	this := p
	_ = this

	localctx = NewLetClauseItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, cqlParserRULE_letClauseItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(588)
		p.Identifier()
	}
	{
		p.SetState(589)
		p.Match(cqlParserT__10)
	}
	{
		p.SetState(590)
		p.expression(0)
	}

	return localctx
}

// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_whereClause
	return p
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterWhereClause(s)
	}
}

func (s *WhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitWhereClause(s)
	}
}

func (p *cqlParser) WhereClause() (localctx IWhereClauseContext) {
	this := p
	_ = this

	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, cqlParserRULE_whereClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(592)
		p.Match(cqlParserT__41)
	}
	{
		p.SetState(593)
		p.expression(0)
	}

	return localctx
}

// IReturnClauseContext is an interface to support dynamic dispatch.
type IReturnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsReturnClauseContext differentiates from other interfaces.
	IsReturnClauseContext()
}

type ReturnClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnClauseContext() *ReturnClauseContext {
	var p = new(ReturnClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_returnClause
	return p
}

func (*ReturnClauseContext) IsReturnClauseContext() {}

func NewReturnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnClauseContext {
	var p = new(ReturnClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_returnClause

	return p
}

func (s *ReturnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterReturnClause(s)
	}
}

func (s *ReturnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitReturnClause(s)
	}
}

func (p *cqlParser) ReturnClause() (localctx IReturnClauseContext) {
	this := p
	_ = this

	localctx = NewReturnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, cqlParserRULE_returnClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(595)
		p.Match(cqlParserT__42)
	}
	p.SetState(597)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(596)
			_la = p.GetTokenStream().LA(1)

			if !(_la == cqlParserT__43 || _la == cqlParserT__44) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(599)
		p.expression(0)
	}

	return localctx
}

// ISortClauseContext is an interface to support dynamic dispatch.
type ISortClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SortDirection() ISortDirectionContext
	AllSortByItem() []ISortByItemContext
	SortByItem(i int) ISortByItemContext

	// IsSortClauseContext differentiates from other interfaces.
	IsSortClauseContext()
}

type SortClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortClauseContext() *SortClauseContext {
	var p = new(SortClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_sortClause
	return p
}

func (*SortClauseContext) IsSortClauseContext() {}

func NewSortClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortClauseContext {
	var p = new(SortClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_sortClause

	return p
}

func (s *SortClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortClauseContext) SortDirection() ISortDirectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortDirectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortDirectionContext)
}

func (s *SortClauseContext) AllSortByItem() []ISortByItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortByItemContext); ok {
			len++
		}
	}

	tst := make([]ISortByItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortByItemContext); ok {
			tst[i] = t.(ISortByItemContext)
			i++
		}
	}

	return tst
}

func (s *SortClauseContext) SortByItem(i int) ISortByItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortByItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortByItemContext)
}

func (s *SortClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterSortClause(s)
	}
}

func (s *SortClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitSortClause(s)
	}
}

func (p *cqlParser) SortClause() (localctx ISortClauseContext) {
	this := p
	_ = this

	localctx = NewSortClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, cqlParserRULE_sortClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(601)
		p.Match(cqlParserT__45)
	}
	p.SetState(612)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case cqlParserT__47, cqlParserT__48, cqlParserT__49, cqlParserT__50:
		{
			p.SetState(602)
			p.SortDirection()
		}

	case cqlParserT__46:
		{
			p.SetState(603)
			p.Match(cqlParserT__46)
		}
		{
			p.SetState(604)
			p.SortByItem()
		}
		p.SetState(609)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(605)
					p.Match(cqlParserT__14)
				}
				{
					p.SetState(606)
					p.SortByItem()
				}

			}
			p.SetState(611)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISortDirectionContext is an interface to support dynamic dispatch.
type ISortDirectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSortDirectionContext differentiates from other interfaces.
	IsSortDirectionContext()
}

type SortDirectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortDirectionContext() *SortDirectionContext {
	var p = new(SortDirectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_sortDirection
	return p
}

func (*SortDirectionContext) IsSortDirectionContext() {}

func NewSortDirectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortDirectionContext {
	var p = new(SortDirectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_sortDirection

	return p
}

func (s *SortDirectionContext) GetParser() antlr.Parser { return s.parser }
func (s *SortDirectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortDirectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortDirectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterSortDirection(s)
	}
}

func (s *SortDirectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitSortDirection(s)
	}
}

func (p *cqlParser) SortDirection() (localctx ISortDirectionContext) {
	this := p
	_ = this

	localctx = NewSortDirectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, cqlParserRULE_sortDirection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(614)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4222124650659840) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISortByItemContext is an interface to support dynamic dispatch.
type ISortByItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionTerm() IExpressionTermContext
	SortDirection() ISortDirectionContext

	// IsSortByItemContext differentiates from other interfaces.
	IsSortByItemContext()
}

type SortByItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortByItemContext() *SortByItemContext {
	var p = new(SortByItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_sortByItem
	return p
}

func (*SortByItemContext) IsSortByItemContext() {}

func NewSortByItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortByItemContext {
	var p = new(SortByItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_sortByItem

	return p
}

func (s *SortByItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortByItemContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}

func (s *SortByItemContext) SortDirection() ISortDirectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortDirectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortDirectionContext)
}

func (s *SortByItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortByItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortByItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterSortByItem(s)
	}
}

func (s *SortByItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitSortByItem(s)
	}
}

func (p *cqlParser) SortByItem() (localctx ISortByItemContext) {
	this := p
	_ = this

	localctx = NewSortByItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, cqlParserRULE_sortByItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(616)
		p.expressionTerm(0)
	}
	p.SetState(618)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(617)
			p.SortDirection()
		}

	}

	return localctx
}

// IQualifiedIdentifierContext is an interface to support dynamic dispatch.
type IQualifiedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllQualifier() []IQualifierContext
	Qualifier(i int) IQualifierContext

	// IsQualifiedIdentifierContext differentiates from other interfaces.
	IsQualifiedIdentifierContext()
}

type QualifiedIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedIdentifierContext() *QualifiedIdentifierContext {
	var p = new(QualifiedIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_qualifiedIdentifier
	return p
}

func (*QualifiedIdentifierContext) IsQualifiedIdentifierContext() {}

func NewQualifiedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedIdentifierContext {
	var p = new(QualifiedIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_qualifiedIdentifier

	return p
}

func (s *QualifiedIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedIdentifierContext) AllQualifier() []IQualifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifierContext); ok {
			len++
		}
	}

	tst := make([]IQualifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifierContext); ok {
			tst[i] = t.(IQualifierContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedIdentifierContext) Qualifier(i int) IQualifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifierContext)
}

func (s *QualifiedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterQualifiedIdentifier(s)
	}
}

func (s *QualifiedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitQualifiedIdentifier(s)
	}
}

func (p *cqlParser) QualifiedIdentifier() (localctx IQualifiedIdentifierContext) {
	this := p
	_ = this

	localctx = NewQualifiedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, cqlParserRULE_qualifiedIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(625)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(620)
				p.Qualifier()
			}
			{
				p.SetState(621)
				p.Match(cqlParserT__16)
			}

		}
		p.SetState(627)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext())
	}
	{
		p.SetState(628)
		p.Identifier()
	}

	return localctx
}

// IQualifiedIdentifierExpressionContext is an interface to support dynamic dispatch.
type IQualifiedIdentifierExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReferentialIdentifier() IReferentialIdentifierContext
	AllQualifierExpression() []IQualifierExpressionContext
	QualifierExpression(i int) IQualifierExpressionContext

	// IsQualifiedIdentifierExpressionContext differentiates from other interfaces.
	IsQualifiedIdentifierExpressionContext()
}

type QualifiedIdentifierExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedIdentifierExpressionContext() *QualifiedIdentifierExpressionContext {
	var p = new(QualifiedIdentifierExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_qualifiedIdentifierExpression
	return p
}

func (*QualifiedIdentifierExpressionContext) IsQualifiedIdentifierExpressionContext() {}

func NewQualifiedIdentifierExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedIdentifierExpressionContext {
	var p = new(QualifiedIdentifierExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_qualifiedIdentifierExpression

	return p
}

func (s *QualifiedIdentifierExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedIdentifierExpressionContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}

func (s *QualifiedIdentifierExpressionContext) AllQualifierExpression() []IQualifierExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifierExpressionContext); ok {
			len++
		}
	}

	tst := make([]IQualifierExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifierExpressionContext); ok {
			tst[i] = t.(IQualifierExpressionContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedIdentifierExpressionContext) QualifierExpression(i int) IQualifierExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifierExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifierExpressionContext)
}

func (s *QualifiedIdentifierExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedIdentifierExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedIdentifierExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterQualifiedIdentifierExpression(s)
	}
}

func (s *QualifiedIdentifierExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitQualifiedIdentifierExpression(s)
	}
}

func (p *cqlParser) QualifiedIdentifierExpression() (localctx IQualifiedIdentifierExpressionContext) {
	this := p
	_ = this

	localctx = NewQualifiedIdentifierExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, cqlParserRULE_qualifiedIdentifierExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(635)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(630)
				p.QualifierExpression()
			}
			{
				p.SetState(631)
				p.Match(cqlParserT__16)
			}

		}
		p.SetState(637)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext())
	}
	{
		p.SetState(638)
		p.ReferentialIdentifier()
	}

	return localctx
}

// IQualifierExpressionContext is an interface to support dynamic dispatch.
type IQualifierExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReferentialIdentifier() IReferentialIdentifierContext

	// IsQualifierExpressionContext differentiates from other interfaces.
	IsQualifierExpressionContext()
}

type QualifierExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifierExpressionContext() *QualifierExpressionContext {
	var p = new(QualifierExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_qualifierExpression
	return p
}

func (*QualifierExpressionContext) IsQualifierExpressionContext() {}

func NewQualifierExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifierExpressionContext {
	var p = new(QualifierExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_qualifierExpression

	return p
}

func (s *QualifierExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifierExpressionContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}

func (s *QualifierExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifierExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifierExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterQualifierExpression(s)
	}
}

func (s *QualifierExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitQualifierExpression(s)
	}
}

func (p *cqlParser) QualifierExpression() (localctx IQualifierExpressionContext) {
	this := p
	_ = this

	localctx = NewQualifierExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, cqlParserRULE_qualifierExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(640)
		p.ReferentialIdentifier()
	}

	return localctx
}

// ISimplePathContext is an interface to support dynamic dispatch.
type ISimplePathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSimplePathContext differentiates from other interfaces.
	IsSimplePathContext()
}

type SimplePathContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplePathContext() *SimplePathContext {
	var p = new(SimplePathContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_simplePath
	return p
}

func (*SimplePathContext) IsSimplePathContext() {}

func NewSimplePathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplePathContext {
	var p = new(SimplePathContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_simplePath

	return p
}

func (s *SimplePathContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplePathContext) CopyFrom(ctx *SimplePathContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SimplePathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplePathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SimplePathIndexerContext struct {
	*SimplePathContext
}

func NewSimplePathIndexerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimplePathIndexerContext {
	var p = new(SimplePathIndexerContext)

	p.SimplePathContext = NewEmptySimplePathContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SimplePathContext))

	return p
}

func (s *SimplePathIndexerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplePathIndexerContext) SimplePath() ISimplePathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplePathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplePathContext)
}

func (s *SimplePathIndexerContext) SimpleLiteral() ISimpleLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleLiteralContext)
}

func (s *SimplePathIndexerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterSimplePathIndexer(s)
	}
}

func (s *SimplePathIndexerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitSimplePathIndexer(s)
	}
}

type SimplePathQualifiedIdentifierContext struct {
	*SimplePathContext
}

func NewSimplePathQualifiedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimplePathQualifiedIdentifierContext {
	var p = new(SimplePathQualifiedIdentifierContext)

	p.SimplePathContext = NewEmptySimplePathContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SimplePathContext))

	return p
}

func (s *SimplePathQualifiedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplePathQualifiedIdentifierContext) SimplePath() ISimplePathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplePathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplePathContext)
}

func (s *SimplePathQualifiedIdentifierContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}

func (s *SimplePathQualifiedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterSimplePathQualifiedIdentifier(s)
	}
}

func (s *SimplePathQualifiedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitSimplePathQualifiedIdentifier(s)
	}
}

type SimplePathReferentialIdentifierContext struct {
	*SimplePathContext
}

func NewSimplePathReferentialIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimplePathReferentialIdentifierContext {
	var p = new(SimplePathReferentialIdentifierContext)

	p.SimplePathContext = NewEmptySimplePathContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SimplePathContext))

	return p
}

func (s *SimplePathReferentialIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplePathReferentialIdentifierContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}

func (s *SimplePathReferentialIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterSimplePathReferentialIdentifier(s)
	}
}

func (s *SimplePathReferentialIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitSimplePathReferentialIdentifier(s)
	}
}

func (p *cqlParser) SimplePath() (localctx ISimplePathContext) {
	return p.simplePath(0)
}

func (p *cqlParser) simplePath(_p int) (localctx ISimplePathContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewSimplePathContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISimplePathContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 112
	p.EnterRecursionRule(localctx, 112, cqlParserRULE_simplePath, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewSimplePathReferentialIdentifierContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(643)
		p.ReferentialIdentifier()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(655)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(653)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSimplePathQualifiedIdentifierContext(p, NewSimplePathContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, cqlParserRULE_simplePath)
				p.SetState(645)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(646)
					p.Match(cqlParserT__16)
				}
				{
					p.SetState(647)
					p.ReferentialIdentifier()
				}

			case 2:
				localctx = NewSimplePathIndexerContext(p, NewSimplePathContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, cqlParserRULE_simplePath)
				p.SetState(648)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(649)
					p.Match(cqlParserT__36)
				}
				{
					p.SetState(650)
					p.SimpleLiteral()
				}
				{
					p.SetState(651)
					p.Match(cqlParserT__39)
				}

			}

		}
		p.SetState(657)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())
	}

	return localctx
}

// ISimpleLiteralContext is an interface to support dynamic dispatch.
type ISimpleLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode
	NUMBER() antlr.TerminalNode

	// IsSimpleLiteralContext differentiates from other interfaces.
	IsSimpleLiteralContext()
}

type SimpleLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleLiteralContext() *SimpleLiteralContext {
	var p = new(SimpleLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_simpleLiteral
	return p
}

func (*SimpleLiteralContext) IsSimpleLiteralContext() {}

func NewSimpleLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleLiteralContext {
	var p = new(SimpleLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_simpleLiteral

	return p
}

func (s *SimpleLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleLiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(cqlParserSTRING, 0)
}

func (s *SimpleLiteralContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(cqlParserNUMBER, 0)
}

func (s *SimpleLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterSimpleLiteral(s)
	}
}

func (s *SimpleLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitSimpleLiteral(s)
	}
}

func (p *cqlParser) SimpleLiteral() (localctx ISimpleLiteralContext) {
	this := p
	_ = this

	localctx = NewSimpleLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, cqlParserRULE_simpleLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(658)
		_la = p.GetTokenStream().LA(1)

		if !(_la == cqlParserSTRING || _la == cqlParserNUMBER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyFrom(ctx *ExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DurationBetweenExpressionContext struct {
	*ExpressionContext
}

func NewDurationBetweenExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DurationBetweenExpressionContext {
	var p = new(DurationBetweenExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *DurationBetweenExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DurationBetweenExpressionContext) PluralDateTimePrecision() IPluralDateTimePrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPluralDateTimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPluralDateTimePrecisionContext)
}

func (s *DurationBetweenExpressionContext) AllExpressionTerm() []IExpressionTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionTermContext); ok {
			len++
		}
	}

	tst := make([]IExpressionTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionTermContext); ok {
			tst[i] = t.(IExpressionTermContext)
			i++
		}
	}

	return tst
}

func (s *DurationBetweenExpressionContext) ExpressionTerm(i int) IExpressionTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}

func (s *DurationBetweenExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterDurationBetweenExpression(s)
	}
}

func (s *DurationBetweenExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitDurationBetweenExpression(s)
	}
}

type InFixSetExpressionContext struct {
	*ExpressionContext
}

func NewInFixSetExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InFixSetExpressionContext {
	var p = new(InFixSetExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *InFixSetExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InFixSetExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InFixSetExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InFixSetExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterInFixSetExpression(s)
	}
}

func (s *InFixSetExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitInFixSetExpression(s)
	}
}

type RetrieveExpressionContext struct {
	*ExpressionContext
}

func NewRetrieveExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RetrieveExpressionContext {
	var p = new(RetrieveExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *RetrieveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RetrieveExpressionContext) Retrieve() IRetrieveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRetrieveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRetrieveContext)
}

func (s *RetrieveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterRetrieveExpression(s)
	}
}

func (s *RetrieveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitRetrieveExpression(s)
	}
}

type TimingExpressionContext struct {
	*ExpressionContext
}

func NewTimingExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimingExpressionContext {
	var p = new(TimingExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *TimingExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimingExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TimingExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TimingExpressionContext) IntervalOperatorPhrase() IIntervalOperatorPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalOperatorPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalOperatorPhraseContext)
}

func (s *TimingExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterTimingExpression(s)
	}
}

func (s *TimingExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitTimingExpression(s)
	}
}

type QueryExpressionContext struct {
	*ExpressionContext
}

func NewQueryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryExpressionContext {
	var p = new(QueryExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *QueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryExpressionContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *QueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterQueryExpression(s)
	}
}

func (s *QueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitQueryExpression(s)
	}
}

type NotExpressionContext struct {
	*ExpressionContext
}

func NewNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NotExpressionContext {
	var p = new(NotExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterNotExpression(s)
	}
}

func (s *NotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitNotExpression(s)
	}
}

type BooleanExpressionContext struct {
	*ExpressionContext
}

func NewBooleanExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BooleanExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterBooleanExpression(s)
	}
}

func (s *BooleanExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitBooleanExpression(s)
	}
}

type OrExpressionContext struct {
	*ExpressionContext
}

func NewOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OrExpressionContext {
	var p = new(OrExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *OrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OrExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterOrExpression(s)
	}
}

func (s *OrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitOrExpression(s)
	}
}

type CastExpressionContext struct {
	*ExpressionContext
}

func NewCastExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastExpressionContext {
	var p = new(CastExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *CastExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastExpressionContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *CastExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterCastExpression(s)
	}
}

func (s *CastExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitCastExpression(s)
	}
}

type AndExpressionContext struct {
	*ExpressionContext
}

func NewAndExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AndExpressionContext {
	var p = new(AndExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *AndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AndExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterAndExpression(s)
	}
}

func (s *AndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitAndExpression(s)
	}
}

type BetweenExpressionContext struct {
	*ExpressionContext
}

func NewBetweenExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenExpressionContext {
	var p = new(BetweenExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *BetweenExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BetweenExpressionContext) AllExpressionTerm() []IExpressionTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionTermContext); ok {
			len++
		}
	}

	tst := make([]IExpressionTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionTermContext); ok {
			tst[i] = t.(IExpressionTermContext)
			i++
		}
	}

	return tst
}

func (s *BetweenExpressionContext) ExpressionTerm(i int) IExpressionTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}

func (s *BetweenExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterBetweenExpression(s)
	}
}

func (s *BetweenExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitBetweenExpression(s)
	}
}

type MembershipExpressionContext struct {
	*ExpressionContext
}

func NewMembershipExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MembershipExpressionContext {
	var p = new(MembershipExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *MembershipExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MembershipExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MembershipExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MembershipExpressionContext) DateTimePrecisionSpecifier() IDateTimePrecisionSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionSpecifierContext)
}

func (s *MembershipExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterMembershipExpression(s)
	}
}

func (s *MembershipExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitMembershipExpression(s)
	}
}

type DifferenceBetweenExpressionContext struct {
	*ExpressionContext
}

func NewDifferenceBetweenExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DifferenceBetweenExpressionContext {
	var p = new(DifferenceBetweenExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *DifferenceBetweenExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DifferenceBetweenExpressionContext) PluralDateTimePrecision() IPluralDateTimePrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPluralDateTimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPluralDateTimePrecisionContext)
}

func (s *DifferenceBetweenExpressionContext) AllExpressionTerm() []IExpressionTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionTermContext); ok {
			len++
		}
	}

	tst := make([]IExpressionTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionTermContext); ok {
			tst[i] = t.(IExpressionTermContext)
			i++
		}
	}

	return tst
}

func (s *DifferenceBetweenExpressionContext) ExpressionTerm(i int) IExpressionTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}

func (s *DifferenceBetweenExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterDifferenceBetweenExpression(s)
	}
}

func (s *DifferenceBetweenExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitDifferenceBetweenExpression(s)
	}
}

type InequalityExpressionContext struct {
	*ExpressionContext
}

func NewInequalityExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InequalityExpressionContext {
	var p = new(InequalityExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *InequalityExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InequalityExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InequalityExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InequalityExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterInequalityExpression(s)
	}
}

func (s *InequalityExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitInequalityExpression(s)
	}
}

type EqualityExpressionContext struct {
	*ExpressionContext
}

func NewEqualityExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EqualityExpressionContext {
	var p = new(EqualityExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *EqualityExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *EqualityExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EqualityExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterEqualityExpression(s)
	}
}

func (s *EqualityExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitEqualityExpression(s)
	}
}

type ExistenceExpressionContext struct {
	*ExpressionContext
}

func NewExistenceExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistenceExpressionContext {
	var p = new(ExistenceExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ExistenceExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistenceExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExistenceExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterExistenceExpression(s)
	}
}

func (s *ExistenceExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitExistenceExpression(s)
	}
}

type ImpliesExpressionContext struct {
	*ExpressionContext
}

func NewImpliesExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImpliesExpressionContext {
	var p = new(ImpliesExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ImpliesExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImpliesExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ImpliesExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ImpliesExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterImpliesExpression(s)
	}
}

func (s *ImpliesExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitImpliesExpression(s)
	}
}

type TermExpressionContext struct {
	*ExpressionContext
}

func NewTermExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TermExpressionContext {
	var p = new(TermExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *TermExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermExpressionContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}

func (s *TermExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterTermExpression(s)
	}
}

func (s *TermExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitTermExpression(s)
	}
}

type TypeExpressionContext struct {
	*ExpressionContext
}

func NewTypeExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeExpressionContext {
	var p = new(TypeExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *TypeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TypeExpressionContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *TypeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterTypeExpression(s)
	}
}

func (s *TypeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitTypeExpression(s)
	}
}

func (p *cqlParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *cqlParser) expression(_p int) (localctx IExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 116
	p.EnterRecursionRule(localctx, 116, cqlParserRULE_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(691)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTermExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(661)
			p.expressionTerm(0)
		}

	case 2:
		localctx = NewRetrieveExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(662)
			p.Retrieve()
		}

	case 3:
		localctx = NewQueryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(663)
			p.Query()
		}

	case 4:
		localctx = NewCastExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(664)
			p.Match(cqlParserT__57)
		}
		{
			p.SetState(665)
			p.expression(0)
		}
		{
			p.SetState(666)
			p.Match(cqlParserT__56)
		}
		{
			p.SetState(667)
			p.TypeSpecifier()
		}

	case 5:
		localctx = NewNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(669)
			p.Match(cqlParserT__52)
		}
		{
			p.SetState(670)
			p.expression(13)
		}

	case 6:
		localctx = NewExistenceExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(671)
			p.Match(cqlParserT__58)
		}
		{
			p.SetState(672)
			p.expression(12)
		}

	case 7:
		localctx = NewDurationBetweenExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(675)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == cqlParserT__62 {
			{
				p.SetState(673)
				p.Match(cqlParserT__62)
			}
			{
				p.SetState(674)
				p.Match(cqlParserT__38)
			}

		}
		{
			p.SetState(677)
			p.PluralDateTimePrecision()
		}
		{
			p.SetState(678)
			p.Match(cqlParserT__60)
		}
		{
			p.SetState(679)
			p.expressionTerm(0)
		}
		{
			p.SetState(680)
			p.Match(cqlParserT__61)
		}
		{
			p.SetState(681)
			p.expressionTerm(0)
		}

	case 8:
		localctx = NewDifferenceBetweenExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(683)
			p.Match(cqlParserT__63)
		}
		{
			p.SetState(684)
			p.Match(cqlParserT__38)
		}
		{
			p.SetState(685)
			p.PluralDateTimePrecision()
		}
		{
			p.SetState(686)
			p.Match(cqlParserT__60)
		}
		{
			p.SetState(687)
			p.expressionTerm(0)
		}
		{
			p.SetState(688)
			p.Match(cqlParserT__61)
		}
		{
			p.SetState(689)
			p.expressionTerm(0)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(741)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(739)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) {
			case 1:
				localctx = NewInequalityExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, cqlParserRULE_expression)
				p.SetState(693)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(694)
					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-22)) & ^0x3f) == 0 && ((int64(1)<<(_la-22))&26388279066627) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(695)
					p.expression(9)
				}

			case 2:
				localctx = NewTimingExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, cqlParserRULE_expression)
				p.SetState(696)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(697)
					p.IntervalOperatorPhrase()
				}
				{
					p.SetState(698)
					p.expression(8)
				}

			case 3:
				localctx = NewEqualityExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, cqlParserRULE_expression)
				p.SetState(700)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(701)
					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&15) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(702)
					p.expression(7)
				}

			case 4:
				localctx = NewMembershipExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, cqlParserRULE_expression)
				p.SetState(703)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(704)
					_la = p.GetTokenStream().LA(1)

					if !(_la == cqlParserT__38 || _la == cqlParserT__70) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(706)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(705)
						p.DateTimePrecisionSpecifier()
					}

				}
				{
					p.SetState(708)
					p.expression(6)
				}

			case 5:
				localctx = NewAndExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, cqlParserRULE_expression)
				p.SetState(709)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(710)
					p.Match(cqlParserT__61)
				}
				{
					p.SetState(711)
					p.expression(5)
				}

			case 6:
				localctx = NewOrExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, cqlParserRULE_expression)
				p.SetState(712)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(713)
					_la = p.GetTokenStream().LA(1)

					if !(_la == cqlParserT__71 || _la == cqlParserT__72) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(714)
					p.expression(4)
				}

			case 7:
				localctx = NewImpliesExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, cqlParserRULE_expression)
				p.SetState(715)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(716)
					p.Match(cqlParserT__73)
				}
				{
					p.SetState(717)
					p.expression(3)
				}

			case 8:
				localctx = NewInFixSetExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, cqlParserRULE_expression)
				p.SetState(718)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(719)
					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-75)) & ^0x3f) == 0 && ((int64(1)<<(_la-75))&15) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(720)
					p.expression(2)
				}

			case 9:
				localctx = NewBooleanExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, cqlParserRULE_expression)
				p.SetState(721)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
				}
				{
					p.SetState(722)
					p.Match(cqlParserT__51)
				}
				p.SetState(724)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == cqlParserT__52 {
					{
						p.SetState(723)
						p.Match(cqlParserT__52)
					}

				}
				{
					p.SetState(726)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&126100789566373888) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			case 10:
				localctx = NewTypeExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, cqlParserRULE_expression)
				p.SetState(727)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
				}
				{
					p.SetState(728)
					_la = p.GetTokenStream().LA(1)

					if !(_la == cqlParserT__51 || _la == cqlParserT__56) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(729)
					p.TypeSpecifier()
				}

			case 11:
				localctx = NewBetweenExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, cqlParserRULE_expression)
				p.SetState(730)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				p.SetState(732)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == cqlParserT__59 {
					{
						p.SetState(731)
						p.Match(cqlParserT__59)
					}

				}
				{
					p.SetState(734)
					p.Match(cqlParserT__60)
				}
				{
					p.SetState(735)
					p.expressionTerm(0)
				}
				{
					p.SetState(736)
					p.Match(cqlParserT__61)
				}
				{
					p.SetState(737)
					p.expressionTerm(0)
				}

			}

		}
		p.SetState(743)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext())
	}

	return localctx
}

// IDateTimePrecisionContext is an interface to support dynamic dispatch.
type IDateTimePrecisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDateTimePrecisionContext differentiates from other interfaces.
	IsDateTimePrecisionContext()
}

type DateTimePrecisionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateTimePrecisionContext() *DateTimePrecisionContext {
	var p = new(DateTimePrecisionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_dateTimePrecision
	return p
}

func (*DateTimePrecisionContext) IsDateTimePrecisionContext() {}

func NewDateTimePrecisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateTimePrecisionContext {
	var p = new(DateTimePrecisionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_dateTimePrecision

	return p
}

func (s *DateTimePrecisionContext) GetParser() antlr.Parser { return s.parser }
func (s *DateTimePrecisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateTimePrecisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateTimePrecisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterDateTimePrecision(s)
	}
}

func (s *DateTimePrecisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitDateTimePrecision(s)
	}
}

func (p *cqlParser) DateTimePrecision() (localctx IDateTimePrecisionContext) {
	this := p
	_ = this

	localctx = NewDateTimePrecisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, cqlParserRULE_dateTimePrecision)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(744)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-79)) & ^0x3f) == 0 && ((int64(1)<<(_la-79))&255) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDateTimeComponentContext is an interface to support dynamic dispatch.
type IDateTimeComponentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DateTimePrecision() IDateTimePrecisionContext

	// IsDateTimeComponentContext differentiates from other interfaces.
	IsDateTimeComponentContext()
}

type DateTimeComponentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateTimeComponentContext() *DateTimeComponentContext {
	var p = new(DateTimeComponentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_dateTimeComponent
	return p
}

func (*DateTimeComponentContext) IsDateTimeComponentContext() {}

func NewDateTimeComponentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateTimeComponentContext {
	var p = new(DateTimeComponentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_dateTimeComponent

	return p
}

func (s *DateTimeComponentContext) GetParser() antlr.Parser { return s.parser }

func (s *DateTimeComponentContext) DateTimePrecision() IDateTimePrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionContext)
}

func (s *DateTimeComponentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateTimeComponentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateTimeComponentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterDateTimeComponent(s)
	}
}

func (s *DateTimeComponentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitDateTimeComponent(s)
	}
}

func (p *cqlParser) DateTimeComponent() (localctx IDateTimeComponentContext) {
	this := p
	_ = this

	localctx = NewDateTimeComponentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, cqlParserRULE_dateTimeComponent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(750)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case cqlParserT__78, cqlParserT__79, cqlParserT__80, cqlParserT__81, cqlParserT__82, cqlParserT__83, cqlParserT__84, cqlParserT__85:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(746)
			p.DateTimePrecision()
		}

	case cqlParserT__86:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(747)
			p.Match(cqlParserT__86)
		}

	case cqlParserT__87:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(748)
			p.Match(cqlParserT__87)
		}

	case cqlParserT__88:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(749)
			p.Match(cqlParserT__88)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPluralDateTimePrecisionContext is an interface to support dynamic dispatch.
type IPluralDateTimePrecisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPluralDateTimePrecisionContext differentiates from other interfaces.
	IsPluralDateTimePrecisionContext()
}

type PluralDateTimePrecisionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPluralDateTimePrecisionContext() *PluralDateTimePrecisionContext {
	var p = new(PluralDateTimePrecisionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_pluralDateTimePrecision
	return p
}

func (*PluralDateTimePrecisionContext) IsPluralDateTimePrecisionContext() {}

func NewPluralDateTimePrecisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PluralDateTimePrecisionContext {
	var p = new(PluralDateTimePrecisionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_pluralDateTimePrecision

	return p
}

func (s *PluralDateTimePrecisionContext) GetParser() antlr.Parser { return s.parser }
func (s *PluralDateTimePrecisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PluralDateTimePrecisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PluralDateTimePrecisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterPluralDateTimePrecision(s)
	}
}

func (s *PluralDateTimePrecisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitPluralDateTimePrecision(s)
	}
}

func (p *cqlParser) PluralDateTimePrecision() (localctx IPluralDateTimePrecisionContext) {
	this := p
	_ = this

	localctx = NewPluralDateTimePrecisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, cqlParserRULE_pluralDateTimePrecision)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(752)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-90)) & ^0x3f) == 0 && ((int64(1)<<(_la-90))&255) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IExpressionTermContext is an interface to support dynamic dispatch.
type IExpressionTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionTermContext differentiates from other interfaces.
	IsExpressionTermContext()
}

type ExpressionTermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionTermContext() *ExpressionTermContext {
	var p = new(ExpressionTermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_expressionTerm
	return p
}

func (*ExpressionTermContext) IsExpressionTermContext() {}

func NewExpressionTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionTermContext {
	var p = new(ExpressionTermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_expressionTerm

	return p
}

func (s *ExpressionTermContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionTermContext) CopyFrom(ctx *ExpressionTermContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AdditionExpressionTermContext struct {
	*ExpressionTermContext
}

func NewAdditionExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdditionExpressionTermContext {
	var p = new(AdditionExpressionTermContext)

	p.ExpressionTermContext = NewEmptyExpressionTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionTermContext))

	return p
}

func (s *AdditionExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditionExpressionTermContext) AllExpressionTerm() []IExpressionTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionTermContext); ok {
			len++
		}
	}

	tst := make([]IExpressionTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionTermContext); ok {
			tst[i] = t.(IExpressionTermContext)
			i++
		}
	}

	return tst
}

func (s *AdditionExpressionTermContext) ExpressionTerm(i int) IExpressionTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}

func (s *AdditionExpressionTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterAdditionExpressionTerm(s)
	}
}

func (s *AdditionExpressionTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitAdditionExpressionTerm(s)
	}
}

type IndexedExpressionTermContext struct {
	*ExpressionTermContext
}

func NewIndexedExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IndexedExpressionTermContext {
	var p = new(IndexedExpressionTermContext)

	p.ExpressionTermContext = NewEmptyExpressionTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionTermContext))

	return p
}

func (s *IndexedExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexedExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}

func (s *IndexedExpressionTermContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexedExpressionTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterIndexedExpressionTerm(s)
	}
}

func (s *IndexedExpressionTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitIndexedExpressionTerm(s)
	}
}

type WidthExpressionTermContext struct {
	*ExpressionTermContext
}

func NewWidthExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WidthExpressionTermContext {
	var p = new(WidthExpressionTermContext)

	p.ExpressionTermContext = NewEmptyExpressionTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionTermContext))

	return p
}

func (s *WidthExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WidthExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}

func (s *WidthExpressionTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterWidthExpressionTerm(s)
	}
}

func (s *WidthExpressionTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitWidthExpressionTerm(s)
	}
}

type SetAggregateExpressionTermContext struct {
	*ExpressionTermContext
}

func NewSetAggregateExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetAggregateExpressionTermContext {
	var p = new(SetAggregateExpressionTermContext)

	p.ExpressionTermContext = NewEmptyExpressionTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionTermContext))

	return p
}

func (s *SetAggregateExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetAggregateExpressionTermContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SetAggregateExpressionTermContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetAggregateExpressionTermContext) DateTimePrecision() IDateTimePrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionContext)
}

func (s *SetAggregateExpressionTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterSetAggregateExpressionTerm(s)
	}
}

func (s *SetAggregateExpressionTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitSetAggregateExpressionTerm(s)
	}
}

type TimeUnitExpressionTermContext struct {
	*ExpressionTermContext
}

func NewTimeUnitExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeUnitExpressionTermContext {
	var p = new(TimeUnitExpressionTermContext)

	p.ExpressionTermContext = NewEmptyExpressionTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionTermContext))

	return p
}

func (s *TimeUnitExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeUnitExpressionTermContext) DateTimeComponent() IDateTimeComponentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimeComponentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimeComponentContext)
}

func (s *TimeUnitExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}

func (s *TimeUnitExpressionTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterTimeUnitExpressionTerm(s)
	}
}

func (s *TimeUnitExpressionTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitTimeUnitExpressionTerm(s)
	}
}

type IfThenElseExpressionTermContext struct {
	*ExpressionTermContext
}

func NewIfThenElseExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IfThenElseExpressionTermContext {
	var p = new(IfThenElseExpressionTermContext)

	p.ExpressionTermContext = NewEmptyExpressionTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionTermContext))

	return p
}

func (s *IfThenElseExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfThenElseExpressionTermContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *IfThenElseExpressionTermContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfThenElseExpressionTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterIfThenElseExpressionTerm(s)
	}
}

func (s *IfThenElseExpressionTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitIfThenElseExpressionTerm(s)
	}
}

type TimeBoundaryExpressionTermContext struct {
	*ExpressionTermContext
}

func NewTimeBoundaryExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeBoundaryExpressionTermContext {
	var p = new(TimeBoundaryExpressionTermContext)

	p.ExpressionTermContext = NewEmptyExpressionTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionTermContext))

	return p
}

func (s *TimeBoundaryExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeBoundaryExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}

func (s *TimeBoundaryExpressionTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterTimeBoundaryExpressionTerm(s)
	}
}

func (s *TimeBoundaryExpressionTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitTimeBoundaryExpressionTerm(s)
	}
}

type ElementExtractorExpressionTermContext struct {
	*ExpressionTermContext
}

func NewElementExtractorExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ElementExtractorExpressionTermContext {
	var p = new(ElementExtractorExpressionTermContext)

	p.ExpressionTermContext = NewEmptyExpressionTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionTermContext))

	return p
}

func (s *ElementExtractorExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementExtractorExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}

func (s *ElementExtractorExpressionTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterElementExtractorExpressionTerm(s)
	}
}

func (s *ElementExtractorExpressionTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitElementExtractorExpressionTerm(s)
	}
}

type ConversionExpressionTermContext struct {
	*ExpressionTermContext
}

func NewConversionExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConversionExpressionTermContext {
	var p = new(ConversionExpressionTermContext)

	p.ExpressionTermContext = NewEmptyExpressionTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionTermContext))

	return p
}

func (s *ConversionExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConversionExpressionTermContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConversionExpressionTermContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *ConversionExpressionTermContext) Unit() IUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitContext)
}

func (s *ConversionExpressionTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterConversionExpressionTerm(s)
	}
}

func (s *ConversionExpressionTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitConversionExpressionTerm(s)
	}
}

type TypeExtentExpressionTermContext struct {
	*ExpressionTermContext
}

func NewTypeExtentExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeExtentExpressionTermContext {
	var p = new(TypeExtentExpressionTermContext)

	p.ExpressionTermContext = NewEmptyExpressionTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionTermContext))

	return p
}

func (s *TypeExtentExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeExtentExpressionTermContext) NamedTypeSpecifier() INamedTypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedTypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedTypeSpecifierContext)
}

func (s *TypeExtentExpressionTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterTypeExtentExpressionTerm(s)
	}
}

func (s *TypeExtentExpressionTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitTypeExtentExpressionTerm(s)
	}
}

type PredecessorExpressionTermContext struct {
	*ExpressionTermContext
}

func NewPredecessorExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredecessorExpressionTermContext {
	var p = new(PredecessorExpressionTermContext)

	p.ExpressionTermContext = NewEmptyExpressionTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionTermContext))

	return p
}

func (s *PredecessorExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredecessorExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}

func (s *PredecessorExpressionTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterPredecessorExpressionTerm(s)
	}
}

func (s *PredecessorExpressionTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitPredecessorExpressionTerm(s)
	}
}

type PointExtractorExpressionTermContext struct {
	*ExpressionTermContext
}

func NewPointExtractorExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PointExtractorExpressionTermContext {
	var p = new(PointExtractorExpressionTermContext)

	p.ExpressionTermContext = NewEmptyExpressionTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionTermContext))

	return p
}

func (s *PointExtractorExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PointExtractorExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}

func (s *PointExtractorExpressionTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterPointExtractorExpressionTerm(s)
	}
}

func (s *PointExtractorExpressionTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitPointExtractorExpressionTerm(s)
	}
}

type MultiplicationExpressionTermContext struct {
	*ExpressionTermContext
}

func NewMultiplicationExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultiplicationExpressionTermContext {
	var p = new(MultiplicationExpressionTermContext)

	p.ExpressionTermContext = NewEmptyExpressionTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionTermContext))

	return p
}

func (s *MultiplicationExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicationExpressionTermContext) AllExpressionTerm() []IExpressionTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionTermContext); ok {
			len++
		}
	}

	tst := make([]IExpressionTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionTermContext); ok {
			tst[i] = t.(IExpressionTermContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicationExpressionTermContext) ExpressionTerm(i int) IExpressionTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}

func (s *MultiplicationExpressionTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterMultiplicationExpressionTerm(s)
	}
}

func (s *MultiplicationExpressionTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitMultiplicationExpressionTerm(s)
	}
}

type AggregateExpressionTermContext struct {
	*ExpressionTermContext
}

func NewAggregateExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AggregateExpressionTermContext {
	var p = new(AggregateExpressionTermContext)

	p.ExpressionTermContext = NewEmptyExpressionTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionTermContext))

	return p
}

func (s *AggregateExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateExpressionTermContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AggregateExpressionTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterAggregateExpressionTerm(s)
	}
}

func (s *AggregateExpressionTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitAggregateExpressionTerm(s)
	}
}

type DurationExpressionTermContext struct {
	*ExpressionTermContext
}

func NewDurationExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DurationExpressionTermContext {
	var p = new(DurationExpressionTermContext)

	p.ExpressionTermContext = NewEmptyExpressionTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionTermContext))

	return p
}

func (s *DurationExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DurationExpressionTermContext) PluralDateTimePrecision() IPluralDateTimePrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPluralDateTimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPluralDateTimePrecisionContext)
}

func (s *DurationExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}

func (s *DurationExpressionTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterDurationExpressionTerm(s)
	}
}

func (s *DurationExpressionTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitDurationExpressionTerm(s)
	}
}

type DifferenceExpressionTermContext struct {
	*ExpressionTermContext
}

func NewDifferenceExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DifferenceExpressionTermContext {
	var p = new(DifferenceExpressionTermContext)

	p.ExpressionTermContext = NewEmptyExpressionTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionTermContext))

	return p
}

func (s *DifferenceExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DifferenceExpressionTermContext) PluralDateTimePrecision() IPluralDateTimePrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPluralDateTimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPluralDateTimePrecisionContext)
}

func (s *DifferenceExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}

func (s *DifferenceExpressionTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterDifferenceExpressionTerm(s)
	}
}

func (s *DifferenceExpressionTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitDifferenceExpressionTerm(s)
	}
}

type CaseExpressionTermContext struct {
	*ExpressionTermContext
}

func NewCaseExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CaseExpressionTermContext {
	var p = new(CaseExpressionTermContext)

	p.ExpressionTermContext = NewEmptyExpressionTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionTermContext))

	return p
}

func (s *CaseExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseExpressionTermContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CaseExpressionTermContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseExpressionTermContext) AllCaseExpressionItem() []ICaseExpressionItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseExpressionItemContext); ok {
			len++
		}
	}

	tst := make([]ICaseExpressionItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseExpressionItemContext); ok {
			tst[i] = t.(ICaseExpressionItemContext)
			i++
		}
	}

	return tst
}

func (s *CaseExpressionTermContext) CaseExpressionItem(i int) ICaseExpressionItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseExpressionItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseExpressionItemContext)
}

func (s *CaseExpressionTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterCaseExpressionTerm(s)
	}
}

func (s *CaseExpressionTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitCaseExpressionTerm(s)
	}
}

type PowerExpressionTermContext struct {
	*ExpressionTermContext
}

func NewPowerExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PowerExpressionTermContext {
	var p = new(PowerExpressionTermContext)

	p.ExpressionTermContext = NewEmptyExpressionTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionTermContext))

	return p
}

func (s *PowerExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerExpressionTermContext) AllExpressionTerm() []IExpressionTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionTermContext); ok {
			len++
		}
	}

	tst := make([]IExpressionTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionTermContext); ok {
			tst[i] = t.(IExpressionTermContext)
			i++
		}
	}

	return tst
}

func (s *PowerExpressionTermContext) ExpressionTerm(i int) IExpressionTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}

func (s *PowerExpressionTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterPowerExpressionTerm(s)
	}
}

func (s *PowerExpressionTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitPowerExpressionTerm(s)
	}
}

type SuccessorExpressionTermContext struct {
	*ExpressionTermContext
}

func NewSuccessorExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SuccessorExpressionTermContext {
	var p = new(SuccessorExpressionTermContext)

	p.ExpressionTermContext = NewEmptyExpressionTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionTermContext))

	return p
}

func (s *SuccessorExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuccessorExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}

func (s *SuccessorExpressionTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterSuccessorExpressionTerm(s)
	}
}

func (s *SuccessorExpressionTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitSuccessorExpressionTerm(s)
	}
}

type PolarityExpressionTermContext struct {
	*ExpressionTermContext
}

func NewPolarityExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PolarityExpressionTermContext {
	var p = new(PolarityExpressionTermContext)

	p.ExpressionTermContext = NewEmptyExpressionTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionTermContext))

	return p
}

func (s *PolarityExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PolarityExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}

func (s *PolarityExpressionTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterPolarityExpressionTerm(s)
	}
}

func (s *PolarityExpressionTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitPolarityExpressionTerm(s)
	}
}

type TermExpressionTermContext struct {
	*ExpressionTermContext
}

func NewTermExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TermExpressionTermContext {
	var p = new(TermExpressionTermContext)

	p.ExpressionTermContext = NewEmptyExpressionTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionTermContext))

	return p
}

func (s *TermExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermExpressionTermContext) Term() ITermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *TermExpressionTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterTermExpressionTerm(s)
	}
}

func (s *TermExpressionTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitTermExpressionTerm(s)
	}
}

type InvocationExpressionTermContext struct {
	*ExpressionTermContext
}

func NewInvocationExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InvocationExpressionTermContext {
	var p = new(InvocationExpressionTermContext)

	p.ExpressionTermContext = NewEmptyExpressionTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionTermContext))

	return p
}

func (s *InvocationExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InvocationExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}

func (s *InvocationExpressionTermContext) QualifiedInvocation() IQualifiedInvocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedInvocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedInvocationContext)
}

func (s *InvocationExpressionTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterInvocationExpressionTerm(s)
	}
}

func (s *InvocationExpressionTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitInvocationExpressionTerm(s)
	}
}

func (p *cqlParser) ExpressionTerm() (localctx IExpressionTermContext) {
	return p.expressionTerm(0)
}

func (p *cqlParser) expressionTerm(_p int) (localctx IExpressionTermContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionTermContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionTermContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 124
	p.EnterRecursionRule(localctx, 124, cqlParserRULE_expressionTerm, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(832)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTermExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(755)
			p.Term()
		}

	case 2:
		localctx = NewConversionExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(756)
			p.Match(cqlParserT__97)
		}
		{
			p.SetState(757)
			p.expression(0)
		}
		{
			p.SetState(758)
			p.Match(cqlParserT__98)
		}
		p.SetState(761)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case cqlParserT__0, cqlParserT__1, cqlParserT__2, cqlParserT__3, cqlParserT__4, cqlParserT__5, cqlParserT__6, cqlParserT__7, cqlParserT__8, cqlParserT__9, cqlParserT__11, cqlParserT__12, cqlParserT__17, cqlParserT__19, cqlParserT__20, cqlParserT__23, cqlParserT__24, cqlParserT__25, cqlParserT__26, cqlParserT__27, cqlParserT__28, cqlParserT__41, cqlParserT__46, cqlParserT__47, cqlParserT__48, cqlParserT__49, cqlParserT__50, cqlParserT__70, cqlParserT__72, cqlParserT__73, cqlParserT__75, cqlParserT__76, cqlParserT__77, cqlParserT__86, cqlParserT__87, cqlParserT__88, cqlParserT__101, cqlParserT__102, cqlParserT__104, cqlParserT__105, cqlParserT__106, cqlParserT__114, cqlParserT__115, cqlParserT__126, cqlParserT__127, cqlParserT__128, cqlParserT__129, cqlParserT__136, cqlParserT__137, cqlParserT__140, cqlParserT__144, cqlParserT__145, cqlParserT__149, cqlParserT__150, cqlParserT__151, cqlParserQUOTEDIDENTIFIER, cqlParserIDENTIFIER, cqlParserDELIMITEDIDENTIFIER:
			{
				p.SetState(759)
				p.TypeSpecifier()
			}

		case cqlParserT__78, cqlParserT__79, cqlParserT__80, cqlParserT__81, cqlParserT__82, cqlParserT__83, cqlParserT__84, cqlParserT__85, cqlParserT__89, cqlParserT__90, cqlParserT__91, cqlParserT__92, cqlParserT__93, cqlParserT__94, cqlParserT__95, cqlParserT__96, cqlParserSTRING:
			{
				p.SetState(760)
				p.Unit()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 3:
		localctx = NewPolarityExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(763)
			_la = p.GetTokenStream().LA(1)

			if !(_la == cqlParserT__99 || _la == cqlParserT__100) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(764)
			p.expressionTerm(18)
		}

	case 4:
		localctx = NewTimeBoundaryExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(765)
			_la = p.GetTokenStream().LA(1)

			if !(_la == cqlParserT__101 || _la == cqlParserT__102) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(766)
			p.Match(cqlParserT__103)
		}
		{
			p.SetState(767)
			p.expressionTerm(17)
		}

	case 5:
		localctx = NewTimeUnitExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(768)
			p.DateTimeComponent()
		}
		{
			p.SetState(769)
			p.Match(cqlParserT__18)
		}
		{
			p.SetState(770)
			p.expressionTerm(16)
		}

	case 6:
		localctx = NewDurationExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(772)
			p.Match(cqlParserT__62)
		}
		{
			p.SetState(773)
			p.Match(cqlParserT__38)
		}
		{
			p.SetState(774)
			p.PluralDateTimePrecision()
		}
		{
			p.SetState(775)
			p.Match(cqlParserT__103)
		}
		{
			p.SetState(776)
			p.expressionTerm(15)
		}

	case 7:
		localctx = NewDifferenceExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(778)
			p.Match(cqlParserT__63)
		}
		{
			p.SetState(779)
			p.Match(cqlParserT__38)
		}
		{
			p.SetState(780)
			p.PluralDateTimePrecision()
		}
		{
			p.SetState(781)
			p.Match(cqlParserT__103)
		}
		{
			p.SetState(782)
			p.expressionTerm(14)
		}

	case 8:
		localctx = NewWidthExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(784)
			p.Match(cqlParserT__104)
		}
		{
			p.SetState(785)
			p.Match(cqlParserT__103)
		}
		{
			p.SetState(786)
			p.expressionTerm(13)
		}

	case 9:
		localctx = NewSuccessorExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(787)
			p.Match(cqlParserT__105)
		}
		{
			p.SetState(788)
			p.Match(cqlParserT__103)
		}
		{
			p.SetState(789)
			p.expressionTerm(12)
		}

	case 10:
		localctx = NewPredecessorExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(790)
			p.Match(cqlParserT__106)
		}
		{
			p.SetState(791)
			p.Match(cqlParserT__103)
		}
		{
			p.SetState(792)
			p.expressionTerm(11)
		}

	case 11:
		localctx = NewElementExtractorExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(793)
			p.Match(cqlParserT__107)
		}
		{
			p.SetState(794)
			p.Match(cqlParserT__18)
		}
		{
			p.SetState(795)
			p.expressionTerm(10)
		}

	case 12:
		localctx = NewPointExtractorExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(796)
			p.Match(cqlParserT__108)
		}
		{
			p.SetState(797)
			p.Match(cqlParserT__18)
		}
		{
			p.SetState(798)
			p.expressionTerm(9)
		}

	case 13:
		localctx = NewTypeExtentExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(799)
			_la = p.GetTokenStream().LA(1)

			if !(_la == cqlParserT__109 || _la == cqlParserT__110) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(800)
			p.NamedTypeSpecifier()
		}

	case 14:
		localctx = NewIfThenElseExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(801)
			p.Match(cqlParserT__117)
		}
		{
			p.SetState(802)
			p.expression(0)
		}
		{
			p.SetState(803)
			p.Match(cqlParserT__118)
		}
		{
			p.SetState(804)
			p.expression(0)
		}
		{
			p.SetState(805)
			p.Match(cqlParserT__119)
		}
		{
			p.SetState(806)
			p.expression(0)
		}

	case 15:
		localctx = NewCaseExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(808)
			p.Match(cqlParserT__120)
		}
		p.SetState(810)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-8219170335514396674) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7036594076661057919) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&8589813255) != 0) {
			{
				p.SetState(809)
				p.expression(0)
			}

		}
		p.SetState(813)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == cqlParserT__125 {
			{
				p.SetState(812)
				p.CaseExpressionItem()
			}

			p.SetState(815)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(817)
			p.Match(cqlParserT__119)
		}
		{
			p.SetState(818)
			p.expression(0)
		}
		{
			p.SetState(819)
			p.Match(cqlParserT__102)
		}

	case 16:
		localctx = NewAggregateExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(821)
			_la = p.GetTokenStream().LA(1)

			if !(_la == cqlParserT__44 || _la == cqlParserT__121) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(822)
			p.expression(0)
		}

	case 17:
		localctx = NewSetAggregateExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(823)
			_la = p.GetTokenStream().LA(1)

			if !(_la == cqlParserT__122 || _la == cqlParserT__123) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(824)
			p.expression(0)
		}
		p.SetState(830)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(825)
				p.Match(cqlParserT__124)
			}
			p.SetState(828)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(826)
					p.DateTimePrecision()
				}

			case 2:
				{
					p.SetState(827)
					p.expression(0)
				}

			}

		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(853)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(851)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext()) {
			case 1:
				localctx = NewPowerExpressionTermContext(p, NewExpressionTermContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, cqlParserRULE_expressionTerm)
				p.SetState(834)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(835)
					p.Match(cqlParserT__111)
				}
				{
					p.SetState(836)
					p.expressionTerm(8)
				}

			case 2:
				localctx = NewMultiplicationExpressionTermContext(p, NewExpressionTermContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, cqlParserRULE_expressionTerm)
				p.SetState(837)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(838)
					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-113)) & ^0x3f) == 0 && ((int64(1)<<(_la-113))&15) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(839)
					p.expressionTerm(7)
				}

			case 3:
				localctx = NewAdditionExpressionTermContext(p, NewExpressionTermContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, cqlParserRULE_expressionTerm)
				p.SetState(840)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(841)
					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-100)) & ^0x3f) == 0 && ((int64(1)<<(_la-100))&131075) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(842)
					p.expressionTerm(6)
				}

			case 4:
				localctx = NewInvocationExpressionTermContext(p, NewExpressionTermContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, cqlParserRULE_expressionTerm)
				p.SetState(843)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
				}
				{
					p.SetState(844)
					p.Match(cqlParserT__16)
				}
				{
					p.SetState(845)
					p.QualifiedInvocation()
				}

			case 5:
				localctx = NewIndexedExpressionTermContext(p, NewExpressionTermContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, cqlParserRULE_expressionTerm)
				p.SetState(846)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
				}
				{
					p.SetState(847)
					p.Match(cqlParserT__36)
				}
				{
					p.SetState(848)
					p.expression(0)
				}
				{
					p.SetState(849)
					p.Match(cqlParserT__39)
				}

			}

		}
		p.SetState(855)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext())
	}

	return localctx
}

// ICaseExpressionItemContext is an interface to support dynamic dispatch.
type ICaseExpressionItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsCaseExpressionItemContext differentiates from other interfaces.
	IsCaseExpressionItemContext()
}

type CaseExpressionItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseExpressionItemContext() *CaseExpressionItemContext {
	var p = new(CaseExpressionItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_caseExpressionItem
	return p
}

func (*CaseExpressionItemContext) IsCaseExpressionItemContext() {}

func NewCaseExpressionItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseExpressionItemContext {
	var p = new(CaseExpressionItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_caseExpressionItem

	return p
}

func (s *CaseExpressionItemContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseExpressionItemContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CaseExpressionItemContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseExpressionItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseExpressionItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseExpressionItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterCaseExpressionItem(s)
	}
}

func (s *CaseExpressionItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitCaseExpressionItem(s)
	}
}

func (p *cqlParser) CaseExpressionItem() (localctx ICaseExpressionItemContext) {
	this := p
	_ = this

	localctx = NewCaseExpressionItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, cqlParserRULE_caseExpressionItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(856)
		p.Match(cqlParserT__125)
	}
	{
		p.SetState(857)
		p.expression(0)
	}
	{
		p.SetState(858)
		p.Match(cqlParserT__118)
	}
	{
		p.SetState(859)
		p.expression(0)
	}

	return localctx
}

// IDateTimePrecisionSpecifierContext is an interface to support dynamic dispatch.
type IDateTimePrecisionSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DateTimePrecision() IDateTimePrecisionContext

	// IsDateTimePrecisionSpecifierContext differentiates from other interfaces.
	IsDateTimePrecisionSpecifierContext()
}

type DateTimePrecisionSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateTimePrecisionSpecifierContext() *DateTimePrecisionSpecifierContext {
	var p = new(DateTimePrecisionSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_dateTimePrecisionSpecifier
	return p
}

func (*DateTimePrecisionSpecifierContext) IsDateTimePrecisionSpecifierContext() {}

func NewDateTimePrecisionSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateTimePrecisionSpecifierContext {
	var p = new(DateTimePrecisionSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_dateTimePrecisionSpecifier

	return p
}

func (s *DateTimePrecisionSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *DateTimePrecisionSpecifierContext) DateTimePrecision() IDateTimePrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionContext)
}

func (s *DateTimePrecisionSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateTimePrecisionSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateTimePrecisionSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterDateTimePrecisionSpecifier(s)
	}
}

func (s *DateTimePrecisionSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitDateTimePrecisionSpecifier(s)
	}
}

func (p *cqlParser) DateTimePrecisionSpecifier() (localctx IDateTimePrecisionSpecifierContext) {
	this := p
	_ = this

	localctx = NewDateTimePrecisionSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, cqlParserRULE_dateTimePrecisionSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(861)
		p.DateTimePrecision()
	}
	{
		p.SetState(862)
		p.Match(cqlParserT__103)
	}

	return localctx
}

// IRelativeQualifierContext is an interface to support dynamic dispatch.
type IRelativeQualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelativeQualifierContext differentiates from other interfaces.
	IsRelativeQualifierContext()
}

type RelativeQualifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelativeQualifierContext() *RelativeQualifierContext {
	var p = new(RelativeQualifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_relativeQualifier
	return p
}

func (*RelativeQualifierContext) IsRelativeQualifierContext() {}

func NewRelativeQualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelativeQualifierContext {
	var p = new(RelativeQualifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_relativeQualifier

	return p
}

func (s *RelativeQualifierContext) GetParser() antlr.Parser { return s.parser }
func (s *RelativeQualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelativeQualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelativeQualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterRelativeQualifier(s)
	}
}

func (s *RelativeQualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitRelativeQualifier(s)
	}
}

func (p *cqlParser) RelativeQualifier() (localctx IRelativeQualifierContext) {
	this := p
	_ = this

	localctx = NewRelativeQualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, cqlParserRULE_relativeQualifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(864)
		_la = p.GetTokenStream().LA(1)

		if !(_la == cqlParserT__126 || _la == cqlParserT__127) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOffsetRelativeQualifierContext is an interface to support dynamic dispatch.
type IOffsetRelativeQualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsOffsetRelativeQualifierContext differentiates from other interfaces.
	IsOffsetRelativeQualifierContext()
}

type OffsetRelativeQualifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOffsetRelativeQualifierContext() *OffsetRelativeQualifierContext {
	var p = new(OffsetRelativeQualifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_offsetRelativeQualifier
	return p
}

func (*OffsetRelativeQualifierContext) IsOffsetRelativeQualifierContext() {}

func NewOffsetRelativeQualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OffsetRelativeQualifierContext {
	var p = new(OffsetRelativeQualifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_offsetRelativeQualifier

	return p
}

func (s *OffsetRelativeQualifierContext) GetParser() antlr.Parser { return s.parser }
func (s *OffsetRelativeQualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OffsetRelativeQualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OffsetRelativeQualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterOffsetRelativeQualifier(s)
	}
}

func (s *OffsetRelativeQualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitOffsetRelativeQualifier(s)
	}
}

func (p *cqlParser) OffsetRelativeQualifier() (localctx IOffsetRelativeQualifierContext) {
	this := p
	_ = this

	localctx = NewOffsetRelativeQualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, cqlParserRULE_offsetRelativeQualifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(866)
		_la = p.GetTokenStream().LA(1)

		if !(_la == cqlParserT__128 || _la == cqlParserT__129) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IExclusiveRelativeQualifierContext is an interface to support dynamic dispatch.
type IExclusiveRelativeQualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExclusiveRelativeQualifierContext differentiates from other interfaces.
	IsExclusiveRelativeQualifierContext()
}

type ExclusiveRelativeQualifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExclusiveRelativeQualifierContext() *ExclusiveRelativeQualifierContext {
	var p = new(ExclusiveRelativeQualifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_exclusiveRelativeQualifier
	return p
}

func (*ExclusiveRelativeQualifierContext) IsExclusiveRelativeQualifierContext() {}

func NewExclusiveRelativeQualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExclusiveRelativeQualifierContext {
	var p = new(ExclusiveRelativeQualifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_exclusiveRelativeQualifier

	return p
}

func (s *ExclusiveRelativeQualifierContext) GetParser() antlr.Parser { return s.parser }
func (s *ExclusiveRelativeQualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExclusiveRelativeQualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExclusiveRelativeQualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterExclusiveRelativeQualifier(s)
	}
}

func (s *ExclusiveRelativeQualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitExclusiveRelativeQualifier(s)
	}
}

func (p *cqlParser) ExclusiveRelativeQualifier() (localctx IExclusiveRelativeQualifierContext) {
	this := p
	_ = this

	localctx = NewExclusiveRelativeQualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, cqlParserRULE_exclusiveRelativeQualifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(868)
		_la = p.GetTokenStream().LA(1)

		if !(_la == cqlParserT__130 || _la == cqlParserT__131) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IQuantityOffsetContext is an interface to support dynamic dispatch.
type IQuantityOffsetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Quantity() IQuantityContext
	OffsetRelativeQualifier() IOffsetRelativeQualifierContext
	ExclusiveRelativeQualifier() IExclusiveRelativeQualifierContext

	// IsQuantityOffsetContext differentiates from other interfaces.
	IsQuantityOffsetContext()
}

type QuantityOffsetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantityOffsetContext() *QuantityOffsetContext {
	var p = new(QuantityOffsetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_quantityOffset
	return p
}

func (*QuantityOffsetContext) IsQuantityOffsetContext() {}

func NewQuantityOffsetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuantityOffsetContext {
	var p = new(QuantityOffsetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_quantityOffset

	return p
}

func (s *QuantityOffsetContext) GetParser() antlr.Parser { return s.parser }

func (s *QuantityOffsetContext) Quantity() IQuantityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantityContext)
}

func (s *QuantityOffsetContext) OffsetRelativeQualifier() IOffsetRelativeQualifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOffsetRelativeQualifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOffsetRelativeQualifierContext)
}

func (s *QuantityOffsetContext) ExclusiveRelativeQualifier() IExclusiveRelativeQualifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExclusiveRelativeQualifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExclusiveRelativeQualifierContext)
}

func (s *QuantityOffsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantityOffsetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuantityOffsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterQuantityOffset(s)
	}
}

func (s *QuantityOffsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitQuantityOffset(s)
	}
}

func (p *cqlParser) QuantityOffset() (localctx IQuantityOffsetContext) {
	this := p
	_ = this

	localctx = NewQuantityOffsetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, cqlParserRULE_quantityOffset)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(877)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case cqlParserNUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(870)
			p.Quantity()
		}
		p.SetState(872)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == cqlParserT__128 || _la == cqlParserT__129 {
			{
				p.SetState(871)
				p.OffsetRelativeQualifier()
			}

		}

	case cqlParserT__130, cqlParserT__131:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(874)
			p.ExclusiveRelativeQualifier()
		}
		{
			p.SetState(875)
			p.Quantity()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITemporalRelationshipContext is an interface to support dynamic dispatch.
type ITemporalRelationshipContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTemporalRelationshipContext differentiates from other interfaces.
	IsTemporalRelationshipContext()
}

type TemporalRelationshipContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemporalRelationshipContext() *TemporalRelationshipContext {
	var p = new(TemporalRelationshipContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_temporalRelationship
	return p
}

func (*TemporalRelationshipContext) IsTemporalRelationshipContext() {}

func NewTemporalRelationshipContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemporalRelationshipContext {
	var p = new(TemporalRelationshipContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_temporalRelationship

	return p
}

func (s *TemporalRelationshipContext) GetParser() antlr.Parser { return s.parser }
func (s *TemporalRelationshipContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemporalRelationshipContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemporalRelationshipContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterTemporalRelationship(s)
	}
}

func (s *TemporalRelationshipContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitTemporalRelationship(s)
	}
}

func (p *cqlParser) TemporalRelationship() (localctx ITemporalRelationshipContext) {
	this := p
	_ = this

	localctx = NewTemporalRelationshipContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, cqlParserRULE_temporalRelationship)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(887)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(880)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == cqlParserT__132 {
			{
				p.SetState(879)
				p.Match(cqlParserT__132)
			}

		}
		{
			p.SetState(882)
			_la = p.GetTokenStream().LA(1)

			if !(_la == cqlParserT__133 || _la == cqlParserT__134) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(883)
			_la = p.GetTokenStream().LA(1)

			if !(_la == cqlParserT__133 || _la == cqlParserT__134) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(885)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == cqlParserT__135 {
			{
				p.SetState(884)
				p.Match(cqlParserT__135)
			}

		}

	}

	return localctx
}

// IIntervalOperatorPhraseContext is an interface to support dynamic dispatch.
type IIntervalOperatorPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIntervalOperatorPhraseContext differentiates from other interfaces.
	IsIntervalOperatorPhraseContext()
}

type IntervalOperatorPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalOperatorPhraseContext() *IntervalOperatorPhraseContext {
	var p = new(IntervalOperatorPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_intervalOperatorPhrase
	return p
}

func (*IntervalOperatorPhraseContext) IsIntervalOperatorPhraseContext() {}

func NewIntervalOperatorPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalOperatorPhraseContext {
	var p = new(IntervalOperatorPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_intervalOperatorPhrase

	return p
}

func (s *IntervalOperatorPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalOperatorPhraseContext) CopyFrom(ctx *IntervalOperatorPhraseContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *IntervalOperatorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalOperatorPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type WithinIntervalOperatorPhraseContext struct {
	*IntervalOperatorPhraseContext
}

func NewWithinIntervalOperatorPhraseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WithinIntervalOperatorPhraseContext {
	var p = new(WithinIntervalOperatorPhraseContext)

	p.IntervalOperatorPhraseContext = NewEmptyIntervalOperatorPhraseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IntervalOperatorPhraseContext))

	return p
}

func (s *WithinIntervalOperatorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithinIntervalOperatorPhraseContext) Quantity() IQuantityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantityContext)
}

func (s *WithinIntervalOperatorPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterWithinIntervalOperatorPhrase(s)
	}
}

func (s *WithinIntervalOperatorPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitWithinIntervalOperatorPhrase(s)
	}
}

type IncludedInIntervalOperatorPhraseContext struct {
	*IntervalOperatorPhraseContext
}

func NewIncludedInIntervalOperatorPhraseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IncludedInIntervalOperatorPhraseContext {
	var p = new(IncludedInIntervalOperatorPhraseContext)

	p.IntervalOperatorPhraseContext = NewEmptyIntervalOperatorPhraseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IntervalOperatorPhraseContext))

	return p
}

func (s *IncludedInIntervalOperatorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IncludedInIntervalOperatorPhraseContext) DateTimePrecisionSpecifier() IDateTimePrecisionSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionSpecifierContext)
}

func (s *IncludedInIntervalOperatorPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterIncludedInIntervalOperatorPhrase(s)
	}
}

func (s *IncludedInIntervalOperatorPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitIncludedInIntervalOperatorPhrase(s)
	}
}

type EndsIntervalOperatorPhraseContext struct {
	*IntervalOperatorPhraseContext
}

func NewEndsIntervalOperatorPhraseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EndsIntervalOperatorPhraseContext {
	var p = new(EndsIntervalOperatorPhraseContext)

	p.IntervalOperatorPhraseContext = NewEmptyIntervalOperatorPhraseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IntervalOperatorPhraseContext))

	return p
}

func (s *EndsIntervalOperatorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndsIntervalOperatorPhraseContext) DateTimePrecisionSpecifier() IDateTimePrecisionSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionSpecifierContext)
}

func (s *EndsIntervalOperatorPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterEndsIntervalOperatorPhrase(s)
	}
}

func (s *EndsIntervalOperatorPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitEndsIntervalOperatorPhrase(s)
	}
}

type ConcurrentWithIntervalOperatorPhraseContext struct {
	*IntervalOperatorPhraseContext
}

func NewConcurrentWithIntervalOperatorPhraseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConcurrentWithIntervalOperatorPhraseContext {
	var p = new(ConcurrentWithIntervalOperatorPhraseContext)

	p.IntervalOperatorPhraseContext = NewEmptyIntervalOperatorPhraseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IntervalOperatorPhraseContext))

	return p
}

func (s *ConcurrentWithIntervalOperatorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcurrentWithIntervalOperatorPhraseContext) RelativeQualifier() IRelativeQualifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelativeQualifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelativeQualifierContext)
}

func (s *ConcurrentWithIntervalOperatorPhraseContext) DateTimePrecision() IDateTimePrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionContext)
}

func (s *ConcurrentWithIntervalOperatorPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterConcurrentWithIntervalOperatorPhrase(s)
	}
}

func (s *ConcurrentWithIntervalOperatorPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitConcurrentWithIntervalOperatorPhrase(s)
	}
}

type OverlapsIntervalOperatorPhraseContext struct {
	*IntervalOperatorPhraseContext
}

func NewOverlapsIntervalOperatorPhraseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OverlapsIntervalOperatorPhraseContext {
	var p = new(OverlapsIntervalOperatorPhraseContext)

	p.IntervalOperatorPhraseContext = NewEmptyIntervalOperatorPhraseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IntervalOperatorPhraseContext))

	return p
}

func (s *OverlapsIntervalOperatorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverlapsIntervalOperatorPhraseContext) DateTimePrecisionSpecifier() IDateTimePrecisionSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionSpecifierContext)
}

func (s *OverlapsIntervalOperatorPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterOverlapsIntervalOperatorPhrase(s)
	}
}

func (s *OverlapsIntervalOperatorPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitOverlapsIntervalOperatorPhrase(s)
	}
}

type IncludesIntervalOperatorPhraseContext struct {
	*IntervalOperatorPhraseContext
}

func NewIncludesIntervalOperatorPhraseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IncludesIntervalOperatorPhraseContext {
	var p = new(IncludesIntervalOperatorPhraseContext)

	p.IntervalOperatorPhraseContext = NewEmptyIntervalOperatorPhraseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IntervalOperatorPhraseContext))

	return p
}

func (s *IncludesIntervalOperatorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IncludesIntervalOperatorPhraseContext) DateTimePrecisionSpecifier() IDateTimePrecisionSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionSpecifierContext)
}

func (s *IncludesIntervalOperatorPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterIncludesIntervalOperatorPhrase(s)
	}
}

func (s *IncludesIntervalOperatorPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitIncludesIntervalOperatorPhrase(s)
	}
}

type BeforeOrAfterIntervalOperatorPhraseContext struct {
	*IntervalOperatorPhraseContext
}

func NewBeforeOrAfterIntervalOperatorPhraseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BeforeOrAfterIntervalOperatorPhraseContext {
	var p = new(BeforeOrAfterIntervalOperatorPhraseContext)

	p.IntervalOperatorPhraseContext = NewEmptyIntervalOperatorPhraseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IntervalOperatorPhraseContext))

	return p
}

func (s *BeforeOrAfterIntervalOperatorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BeforeOrAfterIntervalOperatorPhraseContext) TemporalRelationship() ITemporalRelationshipContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemporalRelationshipContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemporalRelationshipContext)
}

func (s *BeforeOrAfterIntervalOperatorPhraseContext) QuantityOffset() IQuantityOffsetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantityOffsetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantityOffsetContext)
}

func (s *BeforeOrAfterIntervalOperatorPhraseContext) DateTimePrecisionSpecifier() IDateTimePrecisionSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionSpecifierContext)
}

func (s *BeforeOrAfterIntervalOperatorPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterBeforeOrAfterIntervalOperatorPhrase(s)
	}
}

func (s *BeforeOrAfterIntervalOperatorPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitBeforeOrAfterIntervalOperatorPhrase(s)
	}
}

type MeetsIntervalOperatorPhraseContext struct {
	*IntervalOperatorPhraseContext
}

func NewMeetsIntervalOperatorPhraseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MeetsIntervalOperatorPhraseContext {
	var p = new(MeetsIntervalOperatorPhraseContext)

	p.IntervalOperatorPhraseContext = NewEmptyIntervalOperatorPhraseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IntervalOperatorPhraseContext))

	return p
}

func (s *MeetsIntervalOperatorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MeetsIntervalOperatorPhraseContext) DateTimePrecisionSpecifier() IDateTimePrecisionSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionSpecifierContext)
}

func (s *MeetsIntervalOperatorPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterMeetsIntervalOperatorPhrase(s)
	}
}

func (s *MeetsIntervalOperatorPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitMeetsIntervalOperatorPhrase(s)
	}
}

type StartsIntervalOperatorPhraseContext struct {
	*IntervalOperatorPhraseContext
}

func NewStartsIntervalOperatorPhraseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StartsIntervalOperatorPhraseContext {
	var p = new(StartsIntervalOperatorPhraseContext)

	p.IntervalOperatorPhraseContext = NewEmptyIntervalOperatorPhraseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IntervalOperatorPhraseContext))

	return p
}

func (s *StartsIntervalOperatorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartsIntervalOperatorPhraseContext) DateTimePrecisionSpecifier() IDateTimePrecisionSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionSpecifierContext)
}

func (s *StartsIntervalOperatorPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterStartsIntervalOperatorPhrase(s)
	}
}

func (s *StartsIntervalOperatorPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitStartsIntervalOperatorPhrase(s)
	}
}

func (p *cqlParser) IntervalOperatorPhrase() (localctx IIntervalOperatorPhraseContext) {
	this := p
	_ = this

	localctx = NewIntervalOperatorPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, cqlParserRULE_intervalOperatorPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(970)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext()) {
	case 1:
		localctx = NewConcurrentWithIntervalOperatorPhraseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(890)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&7) != 0 {
			{
				p.SetState(889)
				_la = p.GetTokenStream().LA(1)

				if !((int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&7) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(892)
			p.Match(cqlParserT__139)
		}
		p.SetState(894)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-79)) & ^0x3f) == 0 && ((int64(1)<<(_la-79))&255) != 0 {
			{
				p.SetState(893)
				p.DateTimePrecision()
			}

		}
		p.SetState(898)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case cqlParserT__126, cqlParserT__127:
			{
				p.SetState(896)
				p.RelativeQualifier()
			}

		case cqlParserT__56:
			{
				p.SetState(897)
				p.Match(cqlParserT__56)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(901)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(900)
				_la = p.GetTokenStream().LA(1)

				if !(_la == cqlParserT__101 || _la == cqlParserT__102) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case 2:
		localctx = NewIncludesIntervalOperatorPhraseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(904)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == cqlParserT__59 {
			{
				p.SetState(903)
				p.Match(cqlParserT__59)
			}

		}
		{
			p.SetState(906)
			p.Match(cqlParserT__140)
		}
		p.SetState(908)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(907)
				p.DateTimePrecisionSpecifier()
			}

		}
		p.SetState(911)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(910)
				_la = p.GetTokenStream().LA(1)

				if !(_la == cqlParserT__101 || _la == cqlParserT__102) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case 3:
		localctx = NewIncludedInIntervalOperatorPhraseContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(914)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&7) != 0 {
			{
				p.SetState(913)
				_la = p.GetTokenStream().LA(1)

				if !((int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&7) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(917)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == cqlParserT__59 {
			{
				p.SetState(916)
				p.Match(cqlParserT__59)
			}

		}
		{
			p.SetState(919)
			_la = p.GetTokenStream().LA(1)

			if !(_la == cqlParserT__141 || _la == cqlParserT__142) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(921)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(920)
				p.DateTimePrecisionSpecifier()
			}

		}

	case 4:
		localctx = NewBeforeOrAfterIntervalOperatorPhraseContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(924)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&7) != 0 {
			{
				p.SetState(923)
				_la = p.GetTokenStream().LA(1)

				if !((int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&7) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(927)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&536870915) != 0 {
			{
				p.SetState(926)
				p.QuantityOffset()
			}

		}
		{
			p.SetState(929)
			p.TemporalRelationship()
		}
		p.SetState(931)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(930)
				p.DateTimePrecisionSpecifier()
			}

		}
		p.SetState(934)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(933)
				_la = p.GetTokenStream().LA(1)

				if !(_la == cqlParserT__101 || _la == cqlParserT__102) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case 5:
		localctx = NewWithinIntervalOperatorPhraseContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(937)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&7) != 0 {
			{
				p.SetState(936)
				_la = p.GetTokenStream().LA(1)

				if !((int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&7) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(940)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == cqlParserT__59 {
			{
				p.SetState(939)
				p.Match(cqlParserT__59)
			}

		}
		{
			p.SetState(942)
			p.Match(cqlParserT__143)
		}
		{
			p.SetState(943)
			p.Quantity()
		}
		{
			p.SetState(944)
			p.Match(cqlParserT__103)
		}
		p.SetState(946)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(945)
				_la = p.GetTokenStream().LA(1)

				if !(_la == cqlParserT__101 || _la == cqlParserT__102) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case 6:
		localctx = NewMeetsIntervalOperatorPhraseContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(948)
			p.Match(cqlParserT__144)
		}
		p.SetState(950)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == cqlParserT__133 || _la == cqlParserT__134 {
			{
				p.SetState(949)
				_la = p.GetTokenStream().LA(1)

				if !(_la == cqlParserT__133 || _la == cqlParserT__134) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(953)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(952)
				p.DateTimePrecisionSpecifier()
			}

		}

	case 7:
		localctx = NewOverlapsIntervalOperatorPhraseContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(955)
			p.Match(cqlParserT__145)
		}
		p.SetState(957)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == cqlParserT__133 || _la == cqlParserT__134 {
			{
				p.SetState(956)
				_la = p.GetTokenStream().LA(1)

				if !(_la == cqlParserT__133 || _la == cqlParserT__134) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(960)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(959)
				p.DateTimePrecisionSpecifier()
			}

		}

	case 8:
		localctx = NewStartsIntervalOperatorPhraseContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(962)
			p.Match(cqlParserT__136)
		}
		p.SetState(964)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(963)
				p.DateTimePrecisionSpecifier()
			}

		}

	case 9:
		localctx = NewEndsIntervalOperatorPhraseContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(966)
			p.Match(cqlParserT__137)
		}
		p.SetState(968)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(967)
				p.DateTimePrecisionSpecifier()
			}

		}

	}

	return localctx
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_term
	return p
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) CopyFrom(ctx *TermContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExternalConstantTermContext struct {
	*TermContext
}

func NewExternalConstantTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExternalConstantTermContext {
	var p = new(ExternalConstantTermContext)

	p.TermContext = NewEmptyTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TermContext))

	return p
}

func (s *ExternalConstantTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternalConstantTermContext) ExternalConstant() IExternalConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternalConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternalConstantContext)
}

func (s *ExternalConstantTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterExternalConstantTerm(s)
	}
}

func (s *ExternalConstantTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitExternalConstantTerm(s)
	}
}

type TupleSelectorTermContext struct {
	*TermContext
}

func NewTupleSelectorTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TupleSelectorTermContext {
	var p = new(TupleSelectorTermContext)

	p.TermContext = NewEmptyTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TermContext))

	return p
}

func (s *TupleSelectorTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleSelectorTermContext) TupleSelector() ITupleSelectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleSelectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleSelectorContext)
}

func (s *TupleSelectorTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterTupleSelectorTerm(s)
	}
}

func (s *TupleSelectorTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitTupleSelectorTerm(s)
	}
}

type LiteralTermContext struct {
	*TermContext
}

func NewLiteralTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralTermContext {
	var p = new(LiteralTermContext)

	p.TermContext = NewEmptyTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TermContext))

	return p
}

func (s *LiteralTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralTermContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LiteralTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterLiteralTerm(s)
	}
}

func (s *LiteralTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitLiteralTerm(s)
	}
}

type ConceptSelectorTermContext struct {
	*TermContext
}

func NewConceptSelectorTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConceptSelectorTermContext {
	var p = new(ConceptSelectorTermContext)

	p.TermContext = NewEmptyTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TermContext))

	return p
}

func (s *ConceptSelectorTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConceptSelectorTermContext) ConceptSelector() IConceptSelectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConceptSelectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConceptSelectorContext)
}

func (s *ConceptSelectorTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterConceptSelectorTerm(s)
	}
}

func (s *ConceptSelectorTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitConceptSelectorTerm(s)
	}
}

type ParenthesizedTermContext struct {
	*TermContext
}

func NewParenthesizedTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedTermContext {
	var p = new(ParenthesizedTermContext)

	p.TermContext = NewEmptyTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TermContext))

	return p
}

func (s *ParenthesizedTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedTermContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterParenthesizedTerm(s)
	}
}

func (s *ParenthesizedTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitParenthesizedTerm(s)
	}
}

type CodeSelectorTermContext struct {
	*TermContext
}

func NewCodeSelectorTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CodeSelectorTermContext {
	var p = new(CodeSelectorTermContext)

	p.TermContext = NewEmptyTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TermContext))

	return p
}

func (s *CodeSelectorTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeSelectorTermContext) CodeSelector() ICodeSelectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeSelectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeSelectorContext)
}

func (s *CodeSelectorTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterCodeSelectorTerm(s)
	}
}

func (s *CodeSelectorTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitCodeSelectorTerm(s)
	}
}

type InvocationTermContext struct {
	*TermContext
}

func NewInvocationTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InvocationTermContext {
	var p = new(InvocationTermContext)

	p.TermContext = NewEmptyTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TermContext))

	return p
}

func (s *InvocationTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InvocationTermContext) Invocation() IInvocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInvocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInvocationContext)
}

func (s *InvocationTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterInvocationTerm(s)
	}
}

func (s *InvocationTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitInvocationTerm(s)
	}
}

type InstanceSelectorTermContext struct {
	*TermContext
}

func NewInstanceSelectorTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InstanceSelectorTermContext {
	var p = new(InstanceSelectorTermContext)

	p.TermContext = NewEmptyTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TermContext))

	return p
}

func (s *InstanceSelectorTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceSelectorTermContext) InstanceSelector() IInstanceSelectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstanceSelectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstanceSelectorContext)
}

func (s *InstanceSelectorTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterInstanceSelectorTerm(s)
	}
}

func (s *InstanceSelectorTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitInstanceSelectorTerm(s)
	}
}

type IntervalSelectorTermContext struct {
	*TermContext
}

func NewIntervalSelectorTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalSelectorTermContext {
	var p = new(IntervalSelectorTermContext)

	p.TermContext = NewEmptyTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TermContext))

	return p
}

func (s *IntervalSelectorTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalSelectorTermContext) IntervalSelector() IIntervalSelectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalSelectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalSelectorContext)
}

func (s *IntervalSelectorTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterIntervalSelectorTerm(s)
	}
}

func (s *IntervalSelectorTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitIntervalSelectorTerm(s)
	}
}

type ListSelectorTermContext struct {
	*TermContext
}

func NewListSelectorTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListSelectorTermContext {
	var p = new(ListSelectorTermContext)

	p.TermContext = NewEmptyTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TermContext))

	return p
}

func (s *ListSelectorTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListSelectorTermContext) ListSelector() IListSelectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListSelectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListSelectorContext)
}

func (s *ListSelectorTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterListSelectorTerm(s)
	}
}

func (s *ListSelectorTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitListSelectorTerm(s)
	}
}

func (p *cqlParser) Term() (localctx ITermContext) {
	this := p
	_ = this

	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, cqlParserRULE_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(985)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) {
	case 1:
		localctx = NewInvocationTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(972)
			p.Invocation()
		}

	case 2:
		localctx = NewLiteralTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(973)
			p.Literal()
		}

	case 3:
		localctx = NewExternalConstantTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(974)
			p.ExternalConstant()
		}

	case 4:
		localctx = NewIntervalSelectorTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(975)
			p.IntervalSelector()
		}

	case 5:
		localctx = NewTupleSelectorTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(976)
			p.TupleSelector()
		}

	case 6:
		localctx = NewInstanceSelectorTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(977)
			p.InstanceSelector()
		}

	case 7:
		localctx = NewListSelectorTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(978)
			p.ListSelector()
		}

	case 8:
		localctx = NewCodeSelectorTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(979)
			p.CodeSelector()
		}

	case 9:
		localctx = NewConceptSelectorTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(980)
			p.ConceptSelector()
		}

	case 10:
		localctx = NewParenthesizedTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(981)
			p.Match(cqlParserT__29)
		}
		{
			p.SetState(982)
			p.expression(0)
		}
		{
			p.SetState(983)
			p.Match(cqlParserT__30)
		}

	}

	return localctx
}

// IQualifiedInvocationContext is an interface to support dynamic dispatch.
type IQualifiedInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQualifiedInvocationContext differentiates from other interfaces.
	IsQualifiedInvocationContext()
}

type QualifiedInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedInvocationContext() *QualifiedInvocationContext {
	var p = new(QualifiedInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_qualifiedInvocation
	return p
}

func (*QualifiedInvocationContext) IsQualifiedInvocationContext() {}

func NewQualifiedInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedInvocationContext {
	var p = new(QualifiedInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_qualifiedInvocation

	return p
}

func (s *QualifiedInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedInvocationContext) CopyFrom(ctx *QualifiedInvocationContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *QualifiedInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QualifiedFunctionInvocationContext struct {
	*QualifiedInvocationContext
}

func NewQualifiedFunctionInvocationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QualifiedFunctionInvocationContext {
	var p = new(QualifiedFunctionInvocationContext)

	p.QualifiedInvocationContext = NewEmptyQualifiedInvocationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QualifiedInvocationContext))

	return p
}

func (s *QualifiedFunctionInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedFunctionInvocationContext) QualifiedFunction() IQualifiedFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedFunctionContext)
}

func (s *QualifiedFunctionInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterQualifiedFunctionInvocation(s)
	}
}

func (s *QualifiedFunctionInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitQualifiedFunctionInvocation(s)
	}
}

type QualifiedMemberInvocationContext struct {
	*QualifiedInvocationContext
}

func NewQualifiedMemberInvocationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QualifiedMemberInvocationContext {
	var p = new(QualifiedMemberInvocationContext)

	p.QualifiedInvocationContext = NewEmptyQualifiedInvocationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QualifiedInvocationContext))

	return p
}

func (s *QualifiedMemberInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedMemberInvocationContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}

func (s *QualifiedMemberInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterQualifiedMemberInvocation(s)
	}
}

func (s *QualifiedMemberInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitQualifiedMemberInvocation(s)
	}
}

func (p *cqlParser) QualifiedInvocation() (localctx IQualifiedInvocationContext) {
	this := p
	_ = this

	localctx = NewQualifiedInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, cqlParserRULE_qualifiedInvocation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(989)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 109, p.GetParserRuleContext()) {
	case 1:
		localctx = NewQualifiedMemberInvocationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(987)
			p.ReferentialIdentifier()
		}

	case 2:
		localctx = NewQualifiedFunctionInvocationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(988)
			p.QualifiedFunction()
		}

	}

	return localctx
}

// IQualifiedFunctionContext is an interface to support dynamic dispatch.
type IQualifiedFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierOrFunctionIdentifier() IIdentifierOrFunctionIdentifierContext
	ParamList() IParamListContext

	// IsQualifiedFunctionContext differentiates from other interfaces.
	IsQualifiedFunctionContext()
}

type QualifiedFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedFunctionContext() *QualifiedFunctionContext {
	var p = new(QualifiedFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_qualifiedFunction
	return p
}

func (*QualifiedFunctionContext) IsQualifiedFunctionContext() {}

func NewQualifiedFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedFunctionContext {
	var p = new(QualifiedFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_qualifiedFunction

	return p
}

func (s *QualifiedFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedFunctionContext) IdentifierOrFunctionIdentifier() IIdentifierOrFunctionIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrFunctionIdentifierContext)
}

func (s *QualifiedFunctionContext) ParamList() IParamListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamListContext)
}

func (s *QualifiedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterQualifiedFunction(s)
	}
}

func (s *QualifiedFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitQualifiedFunction(s)
	}
}

func (p *cqlParser) QualifiedFunction() (localctx IQualifiedFunctionContext) {
	this := p
	_ = this

	localctx = NewQualifiedFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, cqlParserRULE_qualifiedFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(991)
		p.IdentifierOrFunctionIdentifier()
	}
	{
		p.SetState(992)
		p.Match(cqlParserT__29)
	}
	p.SetState(994)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-8219170335514396674) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7036594076661057919) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&8589813255) != 0) {
		{
			p.SetState(993)
			p.ParamList()
		}

	}
	{
		p.SetState(996)
		p.Match(cqlParserT__30)
	}

	return localctx
}

// IInvocationContext is an interface to support dynamic dispatch.
type IInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsInvocationContext differentiates from other interfaces.
	IsInvocationContext()
}

type InvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInvocationContext() *InvocationContext {
	var p = new(InvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_invocation
	return p
}

func (*InvocationContext) IsInvocationContext() {}

func NewInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InvocationContext {
	var p = new(InvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_invocation

	return p
}

func (s *InvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *InvocationContext) CopyFrom(ctx *InvocationContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *InvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TotalInvocationContext struct {
	*InvocationContext
}

func NewTotalInvocationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TotalInvocationContext {
	var p = new(TotalInvocationContext)

	p.InvocationContext = NewEmptyInvocationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*InvocationContext))

	return p
}

func (s *TotalInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TotalInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterTotalInvocation(s)
	}
}

func (s *TotalInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitTotalInvocation(s)
	}
}

type ThisInvocationContext struct {
	*InvocationContext
}

func NewThisInvocationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ThisInvocationContext {
	var p = new(ThisInvocationContext)

	p.InvocationContext = NewEmptyInvocationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*InvocationContext))

	return p
}

func (s *ThisInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterThisInvocation(s)
	}
}

func (s *ThisInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitThisInvocation(s)
	}
}

type IndexInvocationContext struct {
	*InvocationContext
}

func NewIndexInvocationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IndexInvocationContext {
	var p = new(IndexInvocationContext)

	p.InvocationContext = NewEmptyInvocationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*InvocationContext))

	return p
}

func (s *IndexInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterIndexInvocation(s)
	}
}

func (s *IndexInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitIndexInvocation(s)
	}
}

type FunctionInvocationContext struct {
	*InvocationContext
}

func NewFunctionInvocationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionInvocationContext {
	var p = new(FunctionInvocationContext)

	p.InvocationContext = NewEmptyInvocationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*InvocationContext))

	return p
}

func (s *FunctionInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionInvocationContext) Function() IFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionContext)
}

func (s *FunctionInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterFunctionInvocation(s)
	}
}

func (s *FunctionInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitFunctionInvocation(s)
	}
}

type MemberInvocationContext struct {
	*InvocationContext
}

func NewMemberInvocationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MemberInvocationContext {
	var p = new(MemberInvocationContext)

	p.InvocationContext = NewEmptyInvocationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*InvocationContext))

	return p
}

func (s *MemberInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberInvocationContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}

func (s *MemberInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterMemberInvocation(s)
	}
}

func (s *MemberInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitMemberInvocation(s)
	}
}

func (p *cqlParser) Invocation() (localctx IInvocationContext) {
	this := p
	_ = this

	localctx = NewInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, cqlParserRULE_invocation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1003)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext()) {
	case 1:
		localctx = NewMemberInvocationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(998)
			p.ReferentialIdentifier()
		}

	case 2:
		localctx = NewFunctionInvocationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(999)
			p.Function()
		}

	case 3:
		localctx = NewThisInvocationContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1000)
			p.Match(cqlParserT__146)
		}

	case 4:
		localctx = NewIndexInvocationContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1001)
			p.Match(cqlParserT__147)
		}

	case 5:
		localctx = NewTotalInvocationContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1002)
			p.Match(cqlParserT__148)
		}

	}

	return localctx
}

// IFunctionContext is an interface to support dynamic dispatch.
type IFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReferentialIdentifier() IReferentialIdentifierContext
	ParamList() IParamListContext

	// IsFunctionContext differentiates from other interfaces.
	IsFunctionContext()
}

type FunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionContext() *FunctionContext {
	var p = new(FunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_function
	return p
}

func (*FunctionContext) IsFunctionContext() {}

func NewFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionContext {
	var p = new(FunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_function

	return p
}

func (s *FunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}

func (s *FunctionContext) ParamList() IParamListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamListContext)
}

func (s *FunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterFunction(s)
	}
}

func (s *FunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitFunction(s)
	}
}

func (p *cqlParser) Function() (localctx IFunctionContext) {
	this := p
	_ = this

	localctx = NewFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, cqlParserRULE_function)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1005)
		p.ReferentialIdentifier()
	}
	{
		p.SetState(1006)
		p.Match(cqlParserT__29)
	}
	p.SetState(1008)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-8219170335514396674) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7036594076661057919) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&8589813255) != 0) {
		{
			p.SetState(1007)
			p.ParamList()
		}

	}
	{
		p.SetState(1010)
		p.Match(cqlParserT__30)
	}

	return localctx
}

// IRatioContext is an interface to support dynamic dispatch.
type IRatioContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQuantity() []IQuantityContext
	Quantity(i int) IQuantityContext

	// IsRatioContext differentiates from other interfaces.
	IsRatioContext()
}

type RatioContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRatioContext() *RatioContext {
	var p = new(RatioContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_ratio
	return p
}

func (*RatioContext) IsRatioContext() {}

func NewRatioContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RatioContext {
	var p = new(RatioContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_ratio

	return p
}

func (s *RatioContext) GetParser() antlr.Parser { return s.parser }

func (s *RatioContext) AllQuantity() []IQuantityContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQuantityContext); ok {
			len++
		}
	}

	tst := make([]IQuantityContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQuantityContext); ok {
			tst[i] = t.(IQuantityContext)
			i++
		}
	}

	return tst
}

func (s *RatioContext) Quantity(i int) IQuantityContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantityContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantityContext)
}

func (s *RatioContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RatioContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RatioContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterRatio(s)
	}
}

func (s *RatioContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitRatio(s)
	}
}

func (p *cqlParser) Ratio() (localctx IRatioContext) {
	this := p
	_ = this

	localctx = NewRatioContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, cqlParserRULE_ratio)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1012)
		p.Quantity()
	}
	{
		p.SetState(1013)
		p.Match(cqlParserT__10)
	}
	{
		p.SetState(1014)
		p.Quantity()
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) CopyFrom(ctx *LiteralContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TimeLiteralContext struct {
	*LiteralContext
}

func NewTimeLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeLiteralContext {
	var p = new(TimeLiteralContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *TimeLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeLiteralContext) TIME() antlr.TerminalNode {
	return s.GetToken(cqlParserTIME, 0)
}

func (s *TimeLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterTimeLiteral(s)
	}
}

func (s *TimeLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitTimeLiteral(s)
	}
}

type NullLiteralContext struct {
	*LiteralContext
}

func NewNullLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralContext {
	var p = new(NullLiteralContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

type RatioLiteralContext struct {
	*LiteralContext
}

func NewRatioLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RatioLiteralContext {
	var p = new(RatioLiteralContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *RatioLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RatioLiteralContext) Ratio() IRatioContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRatioContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRatioContext)
}

func (s *RatioLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterRatioLiteral(s)
	}
}

func (s *RatioLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitRatioLiteral(s)
	}
}

type DateTimeLiteralContext struct {
	*LiteralContext
}

func NewDateTimeLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DateTimeLiteralContext {
	var p = new(DateTimeLiteralContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *DateTimeLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateTimeLiteralContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(cqlParserDATETIME, 0)
}

func (s *DateTimeLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterDateTimeLiteral(s)
	}
}

func (s *DateTimeLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitDateTimeLiteral(s)
	}
}

type StringLiteralContext struct {
	*LiteralContext
}

func NewStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(cqlParserSTRING, 0)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

type BooleanLiteralContext struct {
	*LiteralContext
}

func NewBooleanLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

type NumberLiteralContext struct {
	*LiteralContext
}

func NewNumberLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumberLiteralContext {
	var p = new(NumberLiteralContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *NumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(cqlParserNUMBER, 0)
}

func (s *NumberLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterNumberLiteral(s)
	}
}

func (s *NumberLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitNumberLiteral(s)
	}
}

type QuantityLiteralContext struct {
	*LiteralContext
}

func NewQuantityLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuantityLiteralContext {
	var p = new(QuantityLiteralContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *QuantityLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantityLiteralContext) Quantity() IQuantityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantityContext)
}

func (s *QuantityLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterQuantityLiteral(s)
	}
}

func (s *QuantityLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitQuantityLiteral(s)
	}
}

func (p *cqlParser) Literal() (localctx ILiteralContext) {
	this := p
	_ = this

	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, cqlParserRULE_literal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1024)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext()) {
	case 1:
		localctx = NewBooleanLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1016)
			_la = p.GetTokenStream().LA(1)

			if !(_la == cqlParserT__54 || _la == cqlParserT__55) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		localctx = NewNullLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1017)
			p.Match(cqlParserT__53)
		}

	case 3:
		localctx = NewStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1018)
			p.Match(cqlParserSTRING)
		}

	case 4:
		localctx = NewNumberLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1019)
			p.Match(cqlParserNUMBER)
		}

	case 5:
		localctx = NewDateTimeLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1020)
			p.Match(cqlParserDATETIME)
		}

	case 6:
		localctx = NewTimeLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1021)
			p.Match(cqlParserTIME)
		}

	case 7:
		localctx = NewQuantityLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1022)
			p.Quantity()
		}

	case 8:
		localctx = NewRatioLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1023)
			p.Ratio()
		}

	}

	return localctx
}

// IIntervalSelectorContext is an interface to support dynamic dispatch.
type IIntervalSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsIntervalSelectorContext differentiates from other interfaces.
	IsIntervalSelectorContext()
}

type IntervalSelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalSelectorContext() *IntervalSelectorContext {
	var p = new(IntervalSelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_intervalSelector
	return p
}

func (*IntervalSelectorContext) IsIntervalSelectorContext() {}

func NewIntervalSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalSelectorContext {
	var p = new(IntervalSelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_intervalSelector

	return p
}

func (s *IntervalSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalSelectorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *IntervalSelectorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalSelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterIntervalSelector(s)
	}
}

func (s *IntervalSelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitIntervalSelector(s)
	}
}

func (p *cqlParser) IntervalSelector() (localctx IIntervalSelectorContext) {
	this := p
	_ = this

	localctx = NewIntervalSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, cqlParserRULE_intervalSelector)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1026)
		p.Match(cqlParserT__23)
	}
	{
		p.SetState(1027)
		_la = p.GetTokenStream().LA(1)

		if !(_la == cqlParserT__29 || _la == cqlParserT__36) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1028)
		p.expression(0)
	}
	{
		p.SetState(1029)
		p.Match(cqlParserT__14)
	}
	{
		p.SetState(1030)
		p.expression(0)
	}
	{
		p.SetState(1031)
		_la = p.GetTokenStream().LA(1)

		if !(_la == cqlParserT__30 || _la == cqlParserT__39) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITupleSelectorContext is an interface to support dynamic dispatch.
type ITupleSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTupleElementSelector() []ITupleElementSelectorContext
	TupleElementSelector(i int) ITupleElementSelectorContext

	// IsTupleSelectorContext differentiates from other interfaces.
	IsTupleSelectorContext()
}

type TupleSelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleSelectorContext() *TupleSelectorContext {
	var p = new(TupleSelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_tupleSelector
	return p
}

func (*TupleSelectorContext) IsTupleSelectorContext() {}

func NewTupleSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleSelectorContext {
	var p = new(TupleSelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_tupleSelector

	return p
}

func (s *TupleSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleSelectorContext) AllTupleElementSelector() []ITupleElementSelectorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITupleElementSelectorContext); ok {
			len++
		}
	}

	tst := make([]ITupleElementSelectorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITupleElementSelectorContext); ok {
			tst[i] = t.(ITupleElementSelectorContext)
			i++
		}
	}

	return tst
}

func (s *TupleSelectorContext) TupleElementSelector(i int) ITupleElementSelectorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleElementSelectorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleElementSelectorContext)
}

func (s *TupleSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleSelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterTupleSelector(s)
	}
}

func (s *TupleSelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitTupleSelector(s)
	}
}

func (p *cqlParser) TupleSelector() (localctx ITupleSelectorContext) {
	this := p
	_ = this

	localctx = NewTupleSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, cqlParserRULE_tupleSelector)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1034)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cqlParserT__24 {
		{
			p.SetState(1033)
			p.Match(cqlParserT__24)
		}

	}
	{
		p.SetState(1036)
		p.Match(cqlParserT__13)
	}
	p.SetState(1046)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case cqlParserT__10:
		{
			p.SetState(1037)
			p.Match(cqlParserT__10)
		}

	case cqlParserT__0, cqlParserT__1, cqlParserT__2, cqlParserT__3, cqlParserT__4, cqlParserT__5, cqlParserT__6, cqlParserT__7, cqlParserT__8, cqlParserT__9, cqlParserT__11, cqlParserT__12, cqlParserT__17, cqlParserT__19, cqlParserT__26, cqlParserT__27, cqlParserT__28, cqlParserT__41, cqlParserT__46, cqlParserT__47, cqlParserT__48, cqlParserT__49, cqlParserT__50, cqlParserT__70, cqlParserT__72, cqlParserT__73, cqlParserT__75, cqlParserT__76, cqlParserT__77, cqlParserT__86, cqlParserT__87, cqlParserT__88, cqlParserT__101, cqlParserT__102, cqlParserT__104, cqlParserT__105, cqlParserT__106, cqlParserT__114, cqlParserT__115, cqlParserT__126, cqlParserT__127, cqlParserT__128, cqlParserT__129, cqlParserT__136, cqlParserT__137, cqlParserT__140, cqlParserT__144, cqlParserT__145, cqlParserT__149, cqlParserQUOTEDIDENTIFIER, cqlParserIDENTIFIER, cqlParserDELIMITEDIDENTIFIER:
		{
			p.SetState(1038)
			p.TupleElementSelector()
		}
		p.SetState(1043)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == cqlParserT__14 {
			{
				p.SetState(1039)
				p.Match(cqlParserT__14)
			}
			{
				p.SetState(1040)
				p.TupleElementSelector()
			}

			p.SetState(1045)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1048)
		p.Match(cqlParserT__15)
	}

	return localctx
}

// ITupleElementSelectorContext is an interface to support dynamic dispatch.
type ITupleElementSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReferentialIdentifier() IReferentialIdentifierContext
	Expression() IExpressionContext

	// IsTupleElementSelectorContext differentiates from other interfaces.
	IsTupleElementSelectorContext()
}

type TupleElementSelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleElementSelectorContext() *TupleElementSelectorContext {
	var p = new(TupleElementSelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_tupleElementSelector
	return p
}

func (*TupleElementSelectorContext) IsTupleElementSelectorContext() {}

func NewTupleElementSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleElementSelectorContext {
	var p = new(TupleElementSelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_tupleElementSelector

	return p
}

func (s *TupleElementSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleElementSelectorContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}

func (s *TupleElementSelectorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TupleElementSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleElementSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleElementSelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterTupleElementSelector(s)
	}
}

func (s *TupleElementSelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitTupleElementSelector(s)
	}
}

func (p *cqlParser) TupleElementSelector() (localctx ITupleElementSelectorContext) {
	this := p
	_ = this

	localctx = NewTupleElementSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, cqlParserRULE_tupleElementSelector)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1050)
		p.ReferentialIdentifier()
	}
	{
		p.SetState(1051)
		p.Match(cqlParserT__10)
	}
	{
		p.SetState(1052)
		p.expression(0)
	}

	return localctx
}

// IInstanceSelectorContext is an interface to support dynamic dispatch.
type IInstanceSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NamedTypeSpecifier() INamedTypeSpecifierContext
	AllInstanceElementSelector() []IInstanceElementSelectorContext
	InstanceElementSelector(i int) IInstanceElementSelectorContext

	// IsInstanceSelectorContext differentiates from other interfaces.
	IsInstanceSelectorContext()
}

type InstanceSelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstanceSelectorContext() *InstanceSelectorContext {
	var p = new(InstanceSelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_instanceSelector
	return p
}

func (*InstanceSelectorContext) IsInstanceSelectorContext() {}

func NewInstanceSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstanceSelectorContext {
	var p = new(InstanceSelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_instanceSelector

	return p
}

func (s *InstanceSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *InstanceSelectorContext) NamedTypeSpecifier() INamedTypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedTypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedTypeSpecifierContext)
}

func (s *InstanceSelectorContext) AllInstanceElementSelector() []IInstanceElementSelectorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInstanceElementSelectorContext); ok {
			len++
		}
	}

	tst := make([]IInstanceElementSelectorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInstanceElementSelectorContext); ok {
			tst[i] = t.(IInstanceElementSelectorContext)
			i++
		}
	}

	return tst
}

func (s *InstanceSelectorContext) InstanceElementSelector(i int) IInstanceElementSelectorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstanceElementSelectorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstanceElementSelectorContext)
}

func (s *InstanceSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstanceSelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterInstanceSelector(s)
	}
}

func (s *InstanceSelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitInstanceSelector(s)
	}
}

func (p *cqlParser) InstanceSelector() (localctx IInstanceSelectorContext) {
	this := p
	_ = this

	localctx = NewInstanceSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, cqlParserRULE_instanceSelector)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1054)
		p.NamedTypeSpecifier()
	}
	{
		p.SetState(1055)
		p.Match(cqlParserT__13)
	}
	p.SetState(1065)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case cqlParserT__10:
		{
			p.SetState(1056)
			p.Match(cqlParserT__10)
		}

	case cqlParserT__0, cqlParserT__1, cqlParserT__2, cqlParserT__3, cqlParserT__4, cqlParserT__5, cqlParserT__6, cqlParserT__7, cqlParserT__8, cqlParserT__9, cqlParserT__11, cqlParserT__12, cqlParserT__17, cqlParserT__19, cqlParserT__26, cqlParserT__27, cqlParserT__28, cqlParserT__41, cqlParserT__46, cqlParserT__47, cqlParserT__48, cqlParserT__49, cqlParserT__50, cqlParserT__70, cqlParserT__72, cqlParserT__73, cqlParserT__75, cqlParserT__76, cqlParserT__77, cqlParserT__86, cqlParserT__87, cqlParserT__88, cqlParserT__101, cqlParserT__102, cqlParserT__104, cqlParserT__105, cqlParserT__106, cqlParserT__114, cqlParserT__115, cqlParserT__126, cqlParserT__127, cqlParserT__128, cqlParserT__129, cqlParserT__136, cqlParserT__137, cqlParserT__140, cqlParserT__144, cqlParserT__145, cqlParserT__149, cqlParserQUOTEDIDENTIFIER, cqlParserIDENTIFIER, cqlParserDELIMITEDIDENTIFIER:
		{
			p.SetState(1057)
			p.InstanceElementSelector()
		}
		p.SetState(1062)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == cqlParserT__14 {
			{
				p.SetState(1058)
				p.Match(cqlParserT__14)
			}
			{
				p.SetState(1059)
				p.InstanceElementSelector()
			}

			p.SetState(1064)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1067)
		p.Match(cqlParserT__15)
	}

	return localctx
}

// IInstanceElementSelectorContext is an interface to support dynamic dispatch.
type IInstanceElementSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReferentialIdentifier() IReferentialIdentifierContext
	Expression() IExpressionContext

	// IsInstanceElementSelectorContext differentiates from other interfaces.
	IsInstanceElementSelectorContext()
}

type InstanceElementSelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstanceElementSelectorContext() *InstanceElementSelectorContext {
	var p = new(InstanceElementSelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_instanceElementSelector
	return p
}

func (*InstanceElementSelectorContext) IsInstanceElementSelectorContext() {}

func NewInstanceElementSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstanceElementSelectorContext {
	var p = new(InstanceElementSelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_instanceElementSelector

	return p
}

func (s *InstanceElementSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *InstanceElementSelectorContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}

func (s *InstanceElementSelectorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InstanceElementSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceElementSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstanceElementSelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterInstanceElementSelector(s)
	}
}

func (s *InstanceElementSelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitInstanceElementSelector(s)
	}
}

func (p *cqlParser) InstanceElementSelector() (localctx IInstanceElementSelectorContext) {
	this := p
	_ = this

	localctx = NewInstanceElementSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, cqlParserRULE_instanceElementSelector)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1069)
		p.ReferentialIdentifier()
	}
	{
		p.SetState(1070)
		p.Match(cqlParserT__10)
	}
	{
		p.SetState(1071)
		p.expression(0)
	}

	return localctx
}

// IListSelectorContext is an interface to support dynamic dispatch.
type IListSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	TypeSpecifier() ITypeSpecifierContext

	// IsListSelectorContext differentiates from other interfaces.
	IsListSelectorContext()
}

type ListSelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListSelectorContext() *ListSelectorContext {
	var p = new(ListSelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_listSelector
	return p
}

func (*ListSelectorContext) IsListSelectorContext() {}

func NewListSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListSelectorContext {
	var p = new(ListSelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_listSelector

	return p
}

func (s *ListSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *ListSelectorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ListSelectorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ListSelectorContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *ListSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListSelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterListSelector(s)
	}
}

func (s *ListSelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitListSelector(s)
	}
}

func (p *cqlParser) ListSelector() (localctx IListSelectorContext) {
	this := p
	_ = this

	localctx = NewListSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, cqlParserRULE_listSelector)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1080)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cqlParserT__20 {
		{
			p.SetState(1073)
			p.Match(cqlParserT__20)
		}
		p.SetState(1078)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == cqlParserT__21 {
			{
				p.SetState(1074)
				p.Match(cqlParserT__21)
			}
			{
				p.SetState(1075)
				p.TypeSpecifier()
			}
			{
				p.SetState(1076)
				p.Match(cqlParserT__22)
			}

		}

	}
	{
		p.SetState(1082)
		p.Match(cqlParserT__13)
	}
	p.SetState(1091)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-8219170335514396674) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7036594076661057919) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&8589813255) != 0) {
		{
			p.SetState(1083)
			p.expression(0)
		}
		p.SetState(1088)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == cqlParserT__14 {
			{
				p.SetState(1084)
				p.Match(cqlParserT__14)
			}
			{
				p.SetState(1085)
				p.expression(0)
			}

			p.SetState(1090)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1093)
		p.Match(cqlParserT__15)
	}

	return localctx
}

// IDisplayClauseContext is an interface to support dynamic dispatch.
type IDisplayClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode

	// IsDisplayClauseContext differentiates from other interfaces.
	IsDisplayClauseContext()
}

type DisplayClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplayClauseContext() *DisplayClauseContext {
	var p = new(DisplayClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_displayClause
	return p
}

func (*DisplayClauseContext) IsDisplayClauseContext() {}

func NewDisplayClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisplayClauseContext {
	var p = new(DisplayClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_displayClause

	return p
}

func (s *DisplayClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DisplayClauseContext) STRING() antlr.TerminalNode {
	return s.GetToken(cqlParserSTRING, 0)
}

func (s *DisplayClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisplayClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisplayClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterDisplayClause(s)
	}
}

func (s *DisplayClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitDisplayClause(s)
	}
}

func (p *cqlParser) DisplayClause() (localctx IDisplayClauseContext) {
	this := p
	_ = this

	localctx = NewDisplayClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, cqlParserRULE_displayClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1095)
		p.Match(cqlParserT__149)
	}
	{
		p.SetState(1096)
		p.Match(cqlParserSTRING)
	}

	return localctx
}

// ICodeSelectorContext is an interface to support dynamic dispatch.
type ICodeSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode
	CodesystemIdentifier() ICodesystemIdentifierContext
	DisplayClause() IDisplayClauseContext

	// IsCodeSelectorContext differentiates from other interfaces.
	IsCodeSelectorContext()
}

type CodeSelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeSelectorContext() *CodeSelectorContext {
	var p = new(CodeSelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_codeSelector
	return p
}

func (*CodeSelectorContext) IsCodeSelectorContext() {}

func NewCodeSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeSelectorContext {
	var p = new(CodeSelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_codeSelector

	return p
}

func (s *CodeSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeSelectorContext) STRING() antlr.TerminalNode {
	return s.GetToken(cqlParserSTRING, 0)
}

func (s *CodeSelectorContext) CodesystemIdentifier() ICodesystemIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodesystemIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodesystemIdentifierContext)
}

func (s *CodeSelectorContext) DisplayClause() IDisplayClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisplayClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisplayClauseContext)
}

func (s *CodeSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeSelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterCodeSelector(s)
	}
}

func (s *CodeSelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitCodeSelector(s)
	}
}

func (p *cqlParser) CodeSelector() (localctx ICodeSelectorContext) {
	this := p
	_ = this

	localctx = NewCodeSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, cqlParserRULE_codeSelector)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1098)
		p.Match(cqlParserT__150)
	}
	{
		p.SetState(1099)
		p.Match(cqlParserSTRING)
	}
	{
		p.SetState(1100)
		p.Match(cqlParserT__18)
	}
	{
		p.SetState(1101)
		p.CodesystemIdentifier()
	}
	p.SetState(1103)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1102)
			p.DisplayClause()
		}

	}

	return localctx
}

// IConceptSelectorContext is an interface to support dynamic dispatch.
type IConceptSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCodeSelector() []ICodeSelectorContext
	CodeSelector(i int) ICodeSelectorContext
	DisplayClause() IDisplayClauseContext

	// IsConceptSelectorContext differentiates from other interfaces.
	IsConceptSelectorContext()
}

type ConceptSelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConceptSelectorContext() *ConceptSelectorContext {
	var p = new(ConceptSelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_conceptSelector
	return p
}

func (*ConceptSelectorContext) IsConceptSelectorContext() {}

func NewConceptSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConceptSelectorContext {
	var p = new(ConceptSelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_conceptSelector

	return p
}

func (s *ConceptSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *ConceptSelectorContext) AllCodeSelector() []ICodeSelectorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICodeSelectorContext); ok {
			len++
		}
	}

	tst := make([]ICodeSelectorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICodeSelectorContext); ok {
			tst[i] = t.(ICodeSelectorContext)
			i++
		}
	}

	return tst
}

func (s *ConceptSelectorContext) CodeSelector(i int) ICodeSelectorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeSelectorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeSelectorContext)
}

func (s *ConceptSelectorContext) DisplayClause() IDisplayClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisplayClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisplayClauseContext)
}

func (s *ConceptSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConceptSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConceptSelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterConceptSelector(s)
	}
}

func (s *ConceptSelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitConceptSelector(s)
	}
}

func (p *cqlParser) ConceptSelector() (localctx IConceptSelectorContext) {
	this := p
	_ = this

	localctx = NewConceptSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, cqlParserRULE_conceptSelector)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1105)
		p.Match(cqlParserT__151)
	}
	{
		p.SetState(1106)
		p.Match(cqlParserT__13)
	}
	{
		p.SetState(1107)
		p.CodeSelector()
	}
	p.SetState(1112)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cqlParserT__14 {
		{
			p.SetState(1108)
			p.Match(cqlParserT__14)
		}
		{
			p.SetState(1109)
			p.CodeSelector()
		}

		p.SetState(1114)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1115)
		p.Match(cqlParserT__15)
	}
	p.SetState(1117)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1116)
			p.DisplayClause()
		}

	}

	return localctx
}

// IKeywordContext is an interface to support dynamic dispatch.
type IKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsKeywordContext differentiates from other interfaces.
	IsKeywordContext()
}

type KeywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordContext() *KeywordContext {
	var p = new(KeywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_keyword
	return p
}

func (*KeywordContext) IsKeywordContext() {}

func NewKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordContext {
	var p = new(KeywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_keyword

	return p
}

func (s *KeywordContext) GetParser() antlr.Parser { return s.parser }
func (s *KeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterKeyword(s)
	}
}

func (s *KeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitKeyword(s)
	}
}

func (p *cqlParser) Keyword() (localctx IKeywordContext) {
	this := p
	_ = this

	localctx = NewKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, cqlParserRULE_keyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1119)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1528014555138) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-11012914622236799) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&29884391) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IReservedWordContext is an interface to support dynamic dispatch.
type IReservedWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsReservedWordContext differentiates from other interfaces.
	IsReservedWordContext()
}

type ReservedWordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReservedWordContext() *ReservedWordContext {
	var p = new(ReservedWordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_reservedWord
	return p
}

func (*ReservedWordContext) IsReservedWordContext() {}

func NewReservedWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReservedWordContext {
	var p = new(ReservedWordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_reservedWord

	return p
}

func (s *ReservedWordContext) GetParser() antlr.Parser { return s.parser }
func (s *ReservedWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReservedWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReservedWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterReservedWord(s)
	}
}

func (s *ReservedWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitReservedWord(s)
	}
}

func (p *cqlParser) ReservedWord() (localctx IReservedWordContext) {
	this := p
	_ = this

	localctx = NewReservedWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, cqlParserRULE_reservedWord)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1121)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4368789140930560) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&9205587504936222977) != 0) || ((int64((_la-133)) & ^0x3f) == 0 && ((int64(1)<<(_la-133))&790223) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IKeywordIdentifierContext is an interface to support dynamic dispatch.
type IKeywordIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsKeywordIdentifierContext differentiates from other interfaces.
	IsKeywordIdentifierContext()
}

type KeywordIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordIdentifierContext() *KeywordIdentifierContext {
	var p = new(KeywordIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_keywordIdentifier
	return p
}

func (*KeywordIdentifierContext) IsKeywordIdentifierContext() {}

func NewKeywordIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordIdentifierContext {
	var p = new(KeywordIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_keywordIdentifier

	return p
}

func (s *KeywordIdentifierContext) GetParser() antlr.Parser { return s.parser }
func (s *KeywordIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterKeywordIdentifier(s)
	}
}

func (s *KeywordIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitKeywordIdentifier(s)
	}
}

func (p *cqlParser) KeywordIdentifier() (localctx IKeywordIdentifierContext) {
	this := p
	_ = this

	localctx = NewKeywordIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, cqlParserRULE_keywordIdentifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1123)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4367261126375422) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&1080916813829046509) != 0) || ((int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&8979) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IObsoleteIdentifierContext is an interface to support dynamic dispatch.
type IObsoleteIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsObsoleteIdentifierContext differentiates from other interfaces.
	IsObsoleteIdentifierContext()
}

type ObsoleteIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsoleteIdentifierContext() *ObsoleteIdentifierContext {
	var p = new(ObsoleteIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_obsoleteIdentifier
	return p
}

func (*ObsoleteIdentifierContext) IsObsoleteIdentifierContext() {}

func NewObsoleteIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsoleteIdentifierContext {
	var p = new(ObsoleteIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_obsoleteIdentifier

	return p
}

func (s *ObsoleteIdentifierContext) GetParser() antlr.Parser { return s.parser }
func (s *ObsoleteIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsoleteIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsoleteIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterObsoleteIdentifier(s)
	}
}

func (s *ObsoleteIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitObsoleteIdentifier(s)
	}
}

func (p *cqlParser) ObsoleteIdentifier() (localctx IObsoleteIdentifierContext) {
	this := p
	_ = this

	localctx = NewObsoleteIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, cqlParserRULE_obsoleteIdentifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1125)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&585525126164119556) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&6442909697) != 0) || ((int64((_la-150)) & ^0x3f) == 0 && ((int64(1)<<(_la-150))&7) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IFunctionIdentifierContext is an interface to support dynamic dispatch.
type IFunctionIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFunctionIdentifierContext differentiates from other interfaces.
	IsFunctionIdentifierContext()
}

type FunctionIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionIdentifierContext() *FunctionIdentifierContext {
	var p = new(FunctionIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_functionIdentifier
	return p
}

func (*FunctionIdentifierContext) IsFunctionIdentifierContext() {}

func NewFunctionIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionIdentifierContext {
	var p = new(FunctionIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_functionIdentifier

	return p
}

func (s *FunctionIdentifierContext) GetParser() antlr.Parser { return s.parser }
func (s *FunctionIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterFunctionIdentifier(s)
	}
}

func (s *FunctionIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitFunctionIdentifier(s)
	}
}

func (p *cqlParser) FunctionIdentifier() (localctx IFunctionIdentifierContext) {
	this := p
	_ = this

	localctx = NewFunctionIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, cqlParserRULE_functionIdentifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1127)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1528014555138) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-11012914622236799) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&29884103) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITypeNameIdentifierContext is an interface to support dynamic dispatch.
type ITypeNameIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTypeNameIdentifierContext differentiates from other interfaces.
	IsTypeNameIdentifierContext()
}

type TypeNameIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameIdentifierContext() *TypeNameIdentifierContext {
	var p = new(TypeNameIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_typeNameIdentifier
	return p
}

func (*TypeNameIdentifierContext) IsTypeNameIdentifierContext() {}

func NewTypeNameIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameIdentifierContext {
	var p = new(TypeNameIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_typeNameIdentifier

	return p
}

func (s *TypeNameIdentifierContext) GetParser() antlr.Parser { return s.parser }
func (s *TypeNameIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNameIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterTypeNameIdentifier(s)
	}
}

func (s *TypeNameIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitTypeNameIdentifier(s)
	}
}

func (p *cqlParser) TypeNameIdentifier() (localctx ITypeNameIdentifierContext) {
	this := p
	_ = this

	localctx = NewTypeNameIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, cqlParserRULE_typeNameIdentifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1129)
		_la = p.GetTokenStream().LA(1)

		if !(_la == cqlParserT__86 || _la == cqlParserT__87 || _la == cqlParserT__150 || _la == cqlParserT__151) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IReferentialIdentifierContext is an interface to support dynamic dispatch.
type IReferentialIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	KeywordIdentifier() IKeywordIdentifierContext

	// IsReferentialIdentifierContext differentiates from other interfaces.
	IsReferentialIdentifierContext()
}

type ReferentialIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferentialIdentifierContext() *ReferentialIdentifierContext {
	var p = new(ReferentialIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_referentialIdentifier
	return p
}

func (*ReferentialIdentifierContext) IsReferentialIdentifierContext() {}

func NewReferentialIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferentialIdentifierContext {
	var p = new(ReferentialIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_referentialIdentifier

	return p
}

func (s *ReferentialIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferentialIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReferentialIdentifierContext) KeywordIdentifier() IKeywordIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordIdentifierContext)
}

func (s *ReferentialIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferentialIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferentialIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterReferentialIdentifier(s)
	}
}

func (s *ReferentialIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitReferentialIdentifier(s)
	}
}

func (p *cqlParser) ReferentialIdentifier() (localctx IReferentialIdentifierContext) {
	this := p
	_ = this

	localctx = NewReferentialIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, cqlParserRULE_referentialIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1133)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case cqlParserQUOTEDIDENTIFIER, cqlParserIDENTIFIER, cqlParserDELIMITEDIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1131)
			p.Identifier()
		}

	case cqlParserT__0, cqlParserT__1, cqlParserT__2, cqlParserT__3, cqlParserT__4, cqlParserT__5, cqlParserT__6, cqlParserT__7, cqlParserT__8, cqlParserT__9, cqlParserT__11, cqlParserT__12, cqlParserT__17, cqlParserT__19, cqlParserT__26, cqlParserT__27, cqlParserT__28, cqlParserT__41, cqlParserT__46, cqlParserT__47, cqlParserT__48, cqlParserT__49, cqlParserT__50, cqlParserT__70, cqlParserT__72, cqlParserT__73, cqlParserT__75, cqlParserT__76, cqlParserT__77, cqlParserT__86, cqlParserT__87, cqlParserT__88, cqlParserT__101, cqlParserT__102, cqlParserT__104, cqlParserT__105, cqlParserT__106, cqlParserT__114, cqlParserT__115, cqlParserT__126, cqlParserT__127, cqlParserT__128, cqlParserT__129, cqlParserT__136, cqlParserT__137, cqlParserT__140, cqlParserT__144, cqlParserT__145, cqlParserT__149:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1132)
			p.KeywordIdentifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReferentialOrTypeNameIdentifierContext is an interface to support dynamic dispatch.
type IReferentialOrTypeNameIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReferentialIdentifier() IReferentialIdentifierContext
	TypeNameIdentifier() ITypeNameIdentifierContext

	// IsReferentialOrTypeNameIdentifierContext differentiates from other interfaces.
	IsReferentialOrTypeNameIdentifierContext()
}

type ReferentialOrTypeNameIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferentialOrTypeNameIdentifierContext() *ReferentialOrTypeNameIdentifierContext {
	var p = new(ReferentialOrTypeNameIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_referentialOrTypeNameIdentifier
	return p
}

func (*ReferentialOrTypeNameIdentifierContext) IsReferentialOrTypeNameIdentifierContext() {}

func NewReferentialOrTypeNameIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferentialOrTypeNameIdentifierContext {
	var p = new(ReferentialOrTypeNameIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_referentialOrTypeNameIdentifier

	return p
}

func (s *ReferentialOrTypeNameIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferentialOrTypeNameIdentifierContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}

func (s *ReferentialOrTypeNameIdentifierContext) TypeNameIdentifier() ITypeNameIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameIdentifierContext)
}

func (s *ReferentialOrTypeNameIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferentialOrTypeNameIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferentialOrTypeNameIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterReferentialOrTypeNameIdentifier(s)
	}
}

func (s *ReferentialOrTypeNameIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitReferentialOrTypeNameIdentifier(s)
	}
}

func (p *cqlParser) ReferentialOrTypeNameIdentifier() (localctx IReferentialOrTypeNameIdentifierContext) {
	this := p
	_ = this

	localctx = NewReferentialOrTypeNameIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, cqlParserRULE_referentialOrTypeNameIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1137)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1135)
			p.ReferentialIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1136)
			p.TypeNameIdentifier()
		}

	}

	return localctx
}

// IIdentifierOrFunctionIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierOrFunctionIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	FunctionIdentifier() IFunctionIdentifierContext

	// IsIdentifierOrFunctionIdentifierContext differentiates from other interfaces.
	IsIdentifierOrFunctionIdentifierContext()
}

type IdentifierOrFunctionIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrFunctionIdentifierContext() *IdentifierOrFunctionIdentifierContext {
	var p = new(IdentifierOrFunctionIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_identifierOrFunctionIdentifier
	return p
}

func (*IdentifierOrFunctionIdentifierContext) IsIdentifierOrFunctionIdentifierContext() {}

func NewIdentifierOrFunctionIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrFunctionIdentifierContext {
	var p = new(IdentifierOrFunctionIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_identifierOrFunctionIdentifier

	return p
}

func (s *IdentifierOrFunctionIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrFunctionIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierOrFunctionIdentifierContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *IdentifierOrFunctionIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrFunctionIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrFunctionIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterIdentifierOrFunctionIdentifier(s)
	}
}

func (s *IdentifierOrFunctionIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitIdentifierOrFunctionIdentifier(s)
	}
}

func (p *cqlParser) IdentifierOrFunctionIdentifier() (localctx IIdentifierOrFunctionIdentifierContext) {
	this := p
	_ = this

	localctx = NewIdentifierOrFunctionIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, cqlParserRULE_identifierOrFunctionIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1141)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case cqlParserQUOTEDIDENTIFIER, cqlParserIDENTIFIER, cqlParserDELIMITEDIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1139)
			p.Identifier()
		}

	case cqlParserT__0, cqlParserT__1, cqlParserT__2, cqlParserT__3, cqlParserT__4, cqlParserT__5, cqlParserT__6, cqlParserT__7, cqlParserT__8, cqlParserT__9, cqlParserT__11, cqlParserT__12, cqlParserT__17, cqlParserT__18, cqlParserT__19, cqlParserT__20, cqlParserT__23, cqlParserT__24, cqlParserT__26, cqlParserT__27, cqlParserT__28, cqlParserT__33, cqlParserT__34, cqlParserT__35, cqlParserT__38, cqlParserT__40, cqlParserT__41, cqlParserT__42, cqlParserT__43, cqlParserT__44, cqlParserT__45, cqlParserT__46, cqlParserT__47, cqlParserT__48, cqlParserT__49, cqlParserT__50, cqlParserT__51, cqlParserT__52, cqlParserT__53, cqlParserT__54, cqlParserT__55, cqlParserT__56, cqlParserT__57, cqlParserT__58, cqlParserT__59, cqlParserT__60, cqlParserT__61, cqlParserT__62, cqlParserT__63, cqlParserT__70, cqlParserT__71, cqlParserT__72, cqlParserT__73, cqlParserT__75, cqlParserT__76, cqlParserT__77, cqlParserT__78, cqlParserT__79, cqlParserT__80, cqlParserT__81, cqlParserT__82, cqlParserT__83, cqlParserT__84, cqlParserT__85, cqlParserT__86, cqlParserT__87, cqlParserT__88, cqlParserT__89, cqlParserT__90, cqlParserT__91, cqlParserT__92, cqlParserT__93, cqlParserT__94, cqlParserT__95, cqlParserT__96, cqlParserT__97, cqlParserT__98, cqlParserT__101, cqlParserT__102, cqlParserT__103, cqlParserT__104, cqlParserT__105, cqlParserT__106, cqlParserT__107, cqlParserT__109, cqlParserT__110, cqlParserT__114, cqlParserT__115, cqlParserT__117, cqlParserT__118, cqlParserT__119, cqlParserT__120, cqlParserT__121, cqlParserT__122, cqlParserT__123, cqlParserT__124, cqlParserT__125, cqlParserT__126, cqlParserT__127, cqlParserT__128, cqlParserT__129, cqlParserT__133, cqlParserT__134, cqlParserT__136, cqlParserT__137, cqlParserT__138, cqlParserT__139, cqlParserT__140, cqlParserT__141, cqlParserT__142, cqlParserT__143, cqlParserT__144, cqlParserT__145, cqlParserT__149, cqlParserT__150, cqlParserT__151:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1140)
			p.FunctionIdentifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	DELIMITEDIDENTIFIER() antlr.TerminalNode
	QUOTEDIDENTIFIER() antlr.TerminalNode

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(cqlParserIDENTIFIER, 0)
}

func (s *IdentifierContext) DELIMITEDIDENTIFIER() antlr.TerminalNode {
	return s.GetToken(cqlParserDELIMITEDIDENTIFIER, 0)
}

func (s *IdentifierContext) QUOTEDIDENTIFIER() antlr.TerminalNode {
	return s.GetToken(cqlParserQUOTEDIDENTIFIER, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *cqlParser) Identifier() (localctx IIdentifierContext) {
	this := p
	_ = this

	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, cqlParserRULE_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1143)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-154)) & ^0x3f) == 0 && ((int64(1)<<(_la-154))&25) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IExternalConstantContext is an interface to support dynamic dispatch.
type IExternalConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	STRING() antlr.TerminalNode

	// IsExternalConstantContext differentiates from other interfaces.
	IsExternalConstantContext()
}

type ExternalConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternalConstantContext() *ExternalConstantContext {
	var p = new(ExternalConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_externalConstant
	return p
}

func (*ExternalConstantContext) IsExternalConstantContext() {}

func NewExternalConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternalConstantContext {
	var p = new(ExternalConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_externalConstant

	return p
}

func (s *ExternalConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternalConstantContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExternalConstantContext) STRING() antlr.TerminalNode {
	return s.GetToken(cqlParserSTRING, 0)
}

func (s *ExternalConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternalConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternalConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterExternalConstant(s)
	}
}

func (s *ExternalConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitExternalConstant(s)
	}
}

func (p *cqlParser) ExternalConstant() (localctx IExternalConstantContext) {
	this := p
	_ = this

	localctx = NewExternalConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, cqlParserRULE_externalConstant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1145)
		p.Match(cqlParserT__152)
	}
	p.SetState(1148)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case cqlParserQUOTEDIDENTIFIER, cqlParserIDENTIFIER, cqlParserDELIMITEDIDENTIFIER:
		{
			p.SetState(1146)
			p.Identifier()
		}

	case cqlParserSTRING:
		{
			p.SetState(1147)
			p.Match(cqlParserSTRING)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IParamListContext is an interface to support dynamic dispatch.
type IParamListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsParamListContext differentiates from other interfaces.
	IsParamListContext()
}

type ParamListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamListContext() *ParamListContext {
	var p = new(ParamListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_paramList
	return p
}

func (*ParamListContext) IsParamListContext() {}

func NewParamListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamListContext {
	var p = new(ParamListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_paramList

	return p
}

func (s *ParamListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ParamListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParamListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterParamList(s)
	}
}

func (s *ParamListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitParamList(s)
	}
}

func (p *cqlParser) ParamList() (localctx IParamListContext) {
	this := p
	_ = this

	localctx = NewParamListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, cqlParserRULE_paramList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1150)
		p.expression(0)
	}
	p.SetState(1155)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cqlParserT__14 {
		{
			p.SetState(1151)
			p.Match(cqlParserT__14)
		}
		{
			p.SetState(1152)
			p.expression(0)
		}

		p.SetState(1157)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IQuantityContext is an interface to support dynamic dispatch.
type IQuantityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUMBER() antlr.TerminalNode
	Unit() IUnitContext

	// IsQuantityContext differentiates from other interfaces.
	IsQuantityContext()
}

type QuantityContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantityContext() *QuantityContext {
	var p = new(QuantityContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_quantity
	return p
}

func (*QuantityContext) IsQuantityContext() {}

func NewQuantityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuantityContext {
	var p = new(QuantityContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_quantity

	return p
}

func (s *QuantityContext) GetParser() antlr.Parser { return s.parser }

func (s *QuantityContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(cqlParserNUMBER, 0)
}

func (s *QuantityContext) Unit() IUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitContext)
}

func (s *QuantityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuantityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterQuantity(s)
	}
}

func (s *QuantityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitQuantity(s)
	}
}

func (p *cqlParser) Quantity() (localctx IQuantityContext) {
	this := p
	_ = this

	localctx = NewQuantityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, cqlParserRULE_quantity)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1158)
		p.Match(cqlParserNUMBER)
	}
	p.SetState(1160)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1159)
			p.Unit()
		}

	}

	return localctx
}

// IUnitContext is an interface to support dynamic dispatch.
type IUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DateTimePrecision() IDateTimePrecisionContext
	PluralDateTimePrecision() IPluralDateTimePrecisionContext
	STRING() antlr.TerminalNode

	// IsUnitContext differentiates from other interfaces.
	IsUnitContext()
}

type UnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitContext() *UnitContext {
	var p = new(UnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cqlParserRULE_unit
	return p
}

func (*UnitContext) IsUnitContext() {}

func NewUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitContext {
	var p = new(UnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cqlParserRULE_unit

	return p
}

func (s *UnitContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitContext) DateTimePrecision() IDateTimePrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionContext)
}

func (s *UnitContext) PluralDateTimePrecision() IPluralDateTimePrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPluralDateTimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPluralDateTimePrecisionContext)
}

func (s *UnitContext) STRING() antlr.TerminalNode {
	return s.GetToken(cqlParserSTRING, 0)
}

func (s *UnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.EnterUnit(s)
	}
}

func (s *UnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cqlListener); ok {
		listenerT.ExitUnit(s)
	}
}

func (p *cqlParser) Unit() (localctx IUnitContext) {
	this := p
	_ = this

	localctx = NewUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, cqlParserRULE_unit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1165)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case cqlParserT__78, cqlParserT__79, cqlParserT__80, cqlParserT__81, cqlParserT__82, cqlParserT__83, cqlParserT__84, cqlParserT__85:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1162)
			p.DateTimePrecision()
		}

	case cqlParserT__89, cqlParserT__90, cqlParserT__91, cqlParserT__92, cqlParserT__93, cqlParserT__94, cqlParserT__95, cqlParserT__96:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1163)
			p.PluralDateTimePrecision()
		}

	case cqlParserSTRING:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1164)
			p.Match(cqlParserSTRING)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

func (p *cqlParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 56:
		var t *SimplePathContext = nil
		if localctx != nil {
			t = localctx.(*SimplePathContext)
		}
		return p.SimplePath_Sempred(t, predIndex)

	case 58:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 62:
		var t *ExpressionTermContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionTermContext)
		}
		return p.ExpressionTerm_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *cqlParser) SimplePath_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *cqlParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 11)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *cqlParser) ExpressionTerm_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 13:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 21)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 20)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
